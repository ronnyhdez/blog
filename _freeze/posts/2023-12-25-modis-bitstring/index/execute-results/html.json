{
  "hash": "f98d2232034c2401fe087ed2fb76c4ae",
  "result": {
    "markdown": "---\ntitle: \"MODIS pixel bit strings conversion with R\"\ndescription: |\n   MODIS satellite images comes with bit information about pixel's quality. \n   Here, I will show how to read those bits, and categorize them for quality\n   filtering.\ndate: 2023-12-25\ncategories: [MODIS, R, bits]\nlicence: \"CC BY-NC\"\nimage: images/keyboard.png\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n# MODIS and the bit strings\n\nIntro about what is MODIS, where to find the data, bands, metadata and the\nvariables with the bits.\n\n# Bit string conversion\n\nThis is a document that will stay in the project as a reference of the building\nof the process and products to do the bit string conversion per each of the\nMODIS pixels that I have in the research data.\n\nFor testing, exploring and validating the process, the `reflectance_500` dataset\nwas used. Nonetheless, final products written in separate documents will contain\nthe necessary changes to be applied to the rest of datasets obtained from MODIS.\n\n## Variables to convert to bit strings\n\nThere are 4 variables in the dataset with a bitmask that needs to be converted:\n\n-   `state_1km`\n-   `gflags`\n-   `qc_500m`\n-   `q_scan`\n\n#### How many unique values do I have per each of the quality variables?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreflectance_500 |>\n  select(state_1km, gflags, qc_500m, q_scan) |> \n  purrr::map(~unique(.))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$state_1km\n [1]  1033 40969  8392  1034 40970  5384  1289  1801 45068  1545  8397  8398\n[13]  1032  8396  8393  5128 40973 40974 45064  8394 32781   206 36872 32778\n[25] 32777  5640 36876 32776 45066  8334   200   138   136     8    72  8264\n[37]  1544  8332  1802  1288  8328  1546  8268  8330  8205    76   204   141\n[49]   140  8204 40972  8266   137  1290    74  1800 32780  5896 40968   205\n[61]   202   201  8329  8270  5385  5898  5642\n\n$gflags\n[1] 0\n\n$qc_500m\n [1] 1073741824 1073968181 1073954817 1075838976 1073968129 1073755137\n [7] 1073755189 1075852341 1076065281 1946383413 1073969013 1073954869\n[13] 1075852289 1076065333 1076051969 1075576832 1075590145 1075803189\n\n$q_scan\n [1] 14  8  9  2  0  6 15  3 13 11 12  1  7 10  5  4\n```\n:::\n:::\n\n\n#### What is the idea behind the bit mask conversion?\n\nOn minute 2:34 of this [USGS video](https://www.usgs.gov/media/videos/getting-started-modis-v6-surface-reflectance-data-part-3) \nI can find an explanation of part of the process.\n\nIt states that each pixel contains an integer value that must be converted to a\nbit binary value. This can be done with the base R function `intToBits()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unique values in q_scan\nints <- unique(reflectance_500$q_scan)\n\nintToBits(14)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 00 01 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[26] 00 00 00 00 00 00 00\n```\n:::\n:::\n\n\n#### How can I apply the idea to MODIS data?\n\nI'm going to follow this [guide](https://stevemosher.wordpress.com/2012/12/05/modis-qc-bits/) in order to clean the pixels with low quality.\n\n-   If I just run the `inToBits()` function, I will obtain a long bit string, with more information than what I need. That's why I need to shorten this bit string and transform it to an integer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(intToBits(14)[1:8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 1 1 0 0 0 0\n```\n:::\n:::\n\n\n-   Remember that this has to be read from left to right. So the first bit is\n\n0.  \n\n-   The 8 bits are numbered from 0 to 7 (as opposed to the R default).\n-   Each bit represents a power of 2.\n-   We need to reverse this bit string\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbit_string <- as.integer(intToBits(14)[1:8])\nbit_string[8:1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 1 1 1 0\n```\n:::\n\n```{.r .cell-code}\nQC_Data <- data.frame(Integer_Value = 0:255,\n                      Bit7 = NA,\n                      Bit6 = NA,\n                      Bit5 = NA,\n                      Bit4 = NA,\n                      Bit3 = NA,\n                      Bit2 = NA,\n                      Bit1 = NA,\n                      Bit0 = NA,\n                      QA_word1 = NA,\n                      QA_word2 = NA,\n                      QA_word3 = NA,\n                      QA_word4 = NA\n)\n\n\nfor (i in QC_Data$Integer_Value) {\n  # print(i)\n  AsInt <- as.integer(intToBits(i)[1:8])\n  QC_Data[i + 1, 2:9] <- AsInt[8:1]\n}\n```\n:::\n\n\n#### Validation of the process\n\nGiven the steps provided in the tutorial, and the information obtained from the USGS video, I can follow the steps and test if I'm obtaining the correct bit string value based on this information:\n\n![](img/usgs_bit_conversion_video.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using one bitmask value from the dataset\na <- as.integer(intToBits(1075803189)[1:32])\nb <- a[32:1]\n\n#  Using the example value from video\na <- as.integer(intToBits(1131675649)[1:32])\nb <- a[32:1]\n\n# This one is the result of the binary transformation from the video\nvalidation <- c(0,1,0,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)\n\n# Check if object is the same as the one written by hand\nstopifnot(b == validation)\n```\n:::\n\n\n-   The steps does match the final result. Next, I need to apply the same logical conditions to my data.\n\n## Code to apply the bit string conversion to the variables\n\nNow that I know which steps are needed to do the conversion, I need to develop the code further to apply it to each of the variables with a bit mask. On this first try, I will do it with the variable `qc_500m`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test with qc_500\n## Check unique values and add one validation (from the video)\nqc_data <- data.frame(qc_ints = c(unique(reflectance_500$qc_500m), 1131675649))\n\n## Create empty data frame. This case is 32 given that the variable\n## `qc_500m` have 32 bits\nfor (i in c(31:0)) {\n  qc_data[, paste0(\"bit_\", i)] <- NA\n}\n\n# Loop for obtaining bit string from unique values in the variable\nz <- 1\nfor (i in qc_data$qc_ints) {\n  # print(i)\n  transformed <- as.integer(intToBits(i)[1:32])\n  qc_data[z, 2:33] <- transformed[32:1]\n  z <- z + 1\n}\n\n## Create test according to value in video\nprocess_test <- qc_data |> \n  filter(qc_ints == 1131675649) |>\n  select(-qc_ints) |>\n  unite(col = \"new\", bit_31:bit_0, sep = \"\") |> \n  pull() \n\nstopifnot(process_test == \"01000011011101000000000000000001\")\n```\n:::\n\n\n-   Given that I have the bit wise conversion done, I can start with the categorization of the quality.\n\n### Categories for each of the bit strings\n\nContinuing with the variable `qc_500m` from which I have already the bit strings, I can follow the [MODIS documentation](https://lpdaac.usgs.gov/documents/306/MOD09_User_Guide_V6.pdf) to add the categories for each combination of bits.\n\nThis steps can be done in two different ways: using conditionals for each of the bits, or joining the variables with the specif bits:\n\n**One possible solution**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqc_data |> \n  mutate(modland_qa = case_when(\n    bit_1 == 0 & bit_0 == 0 ~ \"ideal quality - all bands\",\n    bit_1 == 0 & bit_0 == 1 ~ \"less than ideal quality - some or all bands\",\n    bit_1 == 1 & bit_0 == 0 ~ \"product not produced due to cloud effects\",\n    bit_1 == 1 & bit_0 == 1 ~ \"product not produced for other reasons\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  paged_table()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"qc_ints\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bit_31\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_30\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_29\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_28\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_27\"],\"name\":[6],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_26\"],\"name\":[7],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_25\"],\"name\":[8],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_24\"],\"name\":[9],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_23\"],\"name\":[10],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_22\"],\"name\":[11],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_21\"],\"name\":[12],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_20\"],\"name\":[13],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_19\"],\"name\":[14],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_18\"],\"name\":[15],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_17\"],\"name\":[16],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_16\"],\"name\":[17],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_15\"],\"name\":[18],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_14\"],\"name\":[19],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_13\"],\"name\":[20],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_12\"],\"name\":[21],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_11\"],\"name\":[22],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_10\"],\"name\":[23],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_9\"],\"name\":[24],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_8\"],\"name\":[25],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_7\"],\"name\":[26],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_6\"],\"name\":[27],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_5\"],\"name\":[28],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_4\"],\"name\":[29],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_3\"],\"name\":[30],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_2\"],\"name\":[31],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_1\"],\"name\":[32],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_0\"],\"name\":[33],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"modland_qa\"],\"name\":[34],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"1073741824\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"0\",\"34\":\"ideal quality - all bands\"},{\"1\":\"1073968181\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073954817\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075838976\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"0\",\"34\":\"ideal quality - all bands\"},{\"1\":\"1073968129\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073755137\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073755189\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075852341\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076065281\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1946383413\",\"2\":\"0\",\"3\":\"1\",\"4\":\"1\",\"5\":\"1\",\"6\":\"0\",\"7\":\"1\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073969013\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"1\",\"25\":\"1\",\"26\":\"0\",\"27\":\"1\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073954869\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075852289\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076065333\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076051969\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075576832\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"0\",\"34\":\"ideal quality - all bands\"},{\"1\":\"1075590145\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075803189\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"},{\"1\":\"1131675649\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"1\",\"9\":\"1\",\"10\":\"0\",\"11\":\"1\",\"12\":\"1\",\"13\":\"1\",\"14\":\"0\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"0\",\"33\":\"1\",\"34\":\"less than ideal quality - some or all bands\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n**Second possible solution**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Second possible solution\nqc_data |> \n  unite(col = \"modland\", c(\"bit_1\", \"bit_0\"), sep = \"\") |> \n  mutate(modland_qa = case_when(\n    modland == \"00\" ~ \"ideal quality - all bands\",\n    modland == \"01\" ~ \"less than ideal quality - some or all bands\",\n    modland == \"10\" ~ \"product not produced due to cloud effects\",\n    modland == \"11\" ~ \"product not produced for other reasons\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  paged_table()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"qc_ints\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"bit_31\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_30\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_29\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_28\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_27\"],\"name\":[6],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_26\"],\"name\":[7],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_25\"],\"name\":[8],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_24\"],\"name\":[9],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_23\"],\"name\":[10],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_22\"],\"name\":[11],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_21\"],\"name\":[12],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_20\"],\"name\":[13],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_19\"],\"name\":[14],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_18\"],\"name\":[15],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_17\"],\"name\":[16],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_16\"],\"name\":[17],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_15\"],\"name\":[18],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_14\"],\"name\":[19],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_13\"],\"name\":[20],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_12\"],\"name\":[21],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_11\"],\"name\":[22],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_10\"],\"name\":[23],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_9\"],\"name\":[24],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_8\"],\"name\":[25],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_7\"],\"name\":[26],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_6\"],\"name\":[27],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_5\"],\"name\":[28],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_4\"],\"name\":[29],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_3\"],\"name\":[30],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"bit_2\"],\"name\":[31],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"modland\"],\"name\":[32],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"modland_qa\"],\"name\":[33],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"1073741824\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"00\",\"33\":\"ideal quality - all bands\"},{\"1\":\"1073968181\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073954817\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075838976\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"00\",\"33\":\"ideal quality - all bands\"},{\"1\":\"1073968129\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073755137\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073755189\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075852341\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076065281\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1946383413\",\"2\":\"0\",\"3\":\"1\",\"4\":\"1\",\"5\":\"1\",\"6\":\"0\",\"7\":\"1\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073969013\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"1\",\"25\":\"1\",\"26\":\"0\",\"27\":\"1\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1073954869\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075852289\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076065333\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1076051969\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"1\",\"13\":\"0\",\"14\":\"0\",\"15\":\"0\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075576832\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"00\",\"33\":\"ideal quality - all bands\"},{\"1\":\"1075590145\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1075803189\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"0\",\"9\":\"0\",\"10\":\"0\",\"11\":\"0\",\"12\":\"0\",\"13\":\"1\",\"14\":\"1\",\"15\":\"1\",\"16\":\"1\",\"17\":\"1\",\"18\":\"0\",\"19\":\"1\",\"20\":\"1\",\"21\":\"1\",\"22\":\"0\",\"23\":\"1\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"1\",\"29\":\"1\",\"30\":\"0\",\"31\":\"1\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"},{\"1\":\"1131675649\",\"2\":\"0\",\"3\":\"1\",\"4\":\"0\",\"5\":\"0\",\"6\":\"0\",\"7\":\"0\",\"8\":\"1\",\"9\":\"1\",\"10\":\"0\",\"11\":\"1\",\"12\":\"1\",\"13\":\"1\",\"14\":\"0\",\"15\":\"1\",\"16\":\"0\",\"17\":\"0\",\"18\":\"0\",\"19\":\"0\",\"20\":\"0\",\"21\":\"0\",\"22\":\"0\",\"23\":\"0\",\"24\":\"0\",\"25\":\"0\",\"26\":\"0\",\"27\":\"0\",\"28\":\"0\",\"29\":\"0\",\"30\":\"0\",\"31\":\"0\",\"32\":\"01\",\"33\":\"less than ideal quality - some or all bands\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n-   I think that it would be easy to read the conditions with the second solution.\n-   For each of the series of bits, I'm going to paste them as just one column.\n\n#### qc_500m complete bit string categories\n\nThe following chunk of code contains all the steps to include all the categories specified in the MODIS documentation. The result of this step will be a data frame with\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqc_500_description <- qc_data |> \n  unite(col = \"modland\", c(\"bit_1\", \"bit_0\"), sep = \"\") |> \n  unite(col = \"band_1\", \n        c(\"bit_5\", \"bit_4\", \"bit_3\", \"bit_2\"), sep = \"\") |> \n  unite(col = \"band_2\", \n        c(\"bit_9\", \"bit_8\", \"bit_7\", \"bit_6\"), sep = \"\") |> \n  unite(col = \"band_3\", \n        c(\"bit_13\", \"bit_12\", \"bit_11\", \"bit_10\"), sep = \"\") |> \n  unite(col = \"band_4\", \n        c(\"bit_17\", \"bit_16\", \"bit_15\", \"bit_14\"), sep = \"\") |> \n  unite(col = \"band_5\", \n        c(\"bit_21\", \"bit_20\", \"bit_19\", \"bit_18\"), sep = \"\") |> \n  unite(col = \"band_6\", \n        c(\"bit_25\", \"bit_24\", \"bit_23\", \"bit_22\"), sep = \"\") |>\n  unite(col = \"band_7\", \n        c(\"bit_29\", \"bit_28\", \"bit_27\", \"bit_26\"), sep = \"\") |> \n  mutate(modland_qa = case_when(\n    modland == \"00\" ~ \"ideal quality - all bands\",\n    modland == \"01\" ~ \"less than ideal quality - some or all bands\",\n    modland == \"10\" ~ \"product not produced due to cloud effects\",\n    modland == \"11\" ~ \"product not produced for other reasons\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band1_qa = case_when(\n    band_1 == \"0000\" ~ \"highest_quality\",\n    band_1 == \"0111\" ~ \"noisy detector\",\n    band_1 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_1 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_1 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_1 == \"1011\" ~ \"missing input\",\n    band_1 == \"1100\" ~ \"internal constant used\",\n    band_1 == \"1101\" ~ \"correction out of bounds\",\n    band_1 == \"1110\" ~ \"L1B data faulty\",\n    band_1 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band2_qa = case_when(\n    band_2 == \"0000\" ~ \"highest_quality\",\n    band_2 == \"0111\" ~ \"noisy detector\",\n    band_2 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_2 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_2 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_2 == \"1011\" ~ \"missing input\",\n    band_2 == \"1100\" ~ \"internal constant used\",\n    band_2 == \"1101\" ~ \"correction out of bounds\",\n    band_2 == \"1110\" ~ \"L1B data faulty\",\n    band_2 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band3_qa = case_when(\n    band_3 == \"0000\" ~ \"highest_quality\",\n    band_3 == \"0111\" ~ \"noisy detector\",\n    band_3 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_3 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_3 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_3 == \"1011\" ~ \"missing input\",\n    band_3 == \"1100\" ~ \"internal constant used\",\n    band_3 == \"1101\" ~ \"correction out of bounds\",\n    band_3 == \"1110\" ~ \"L1B data faulty\",\n    band_3 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band4_qa = case_when(\n    band_4 == \"0000\" ~ \"highest_quality\",\n    band_4 == \"0111\" ~ \"noisy detector\",\n    band_4 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_4 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_4 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_4 == \"1011\" ~ \"missing input\",\n    band_4 == \"1100\" ~ \"internal constant used\",\n    band_4 == \"1101\" ~ \"correction out of bounds\",\n    band_4 == \"1110\" ~ \"L1B data faulty\",\n    band_4 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band5_qa = case_when(\n    band_5 == \"0000\" ~ \"highest_quality\",\n    band_5 == \"0111\" ~ \"noisy detector\",\n    band_5 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_5 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_5 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_5 == \"1011\" ~ \"missing input\",\n    band_5 == \"1100\" ~ \"internal constant used\",\n    band_5 == \"1101\" ~ \"correction out of bounds\",\n    band_5 == \"1110\" ~ \"L1B data faulty\",\n    band_5 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band6_qa = case_when(\n    band_6 == \"0000\" ~ \"highest_quality\",\n    band_6 == \"0111\" ~ \"noisy detector\",\n    band_6 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_6 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_6 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_6 == \"1011\" ~ \"missing input\",\n    band_6 == \"1100\" ~ \"internal constant used\",\n    band_6 == \"1101\" ~ \"correction out of bounds\",\n    band_6 == \"1110\" ~ \"L1B data faulty\",\n    band_6 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(band7_qa = case_when(\n    band_7 == \"0000\" ~ \"highest_quality\",\n    band_7 == \"0111\" ~ \"noisy detector\",\n    band_7 == \"1000\" ~ \"dead detector, data interpolated in L1B\",\n    band_7 == \"1001\" ~ \"solar zenith >= 86 degrees\",\n    band_7 == \"1010\" ~ \"solar zenith >= 85 and < 86 degrees\",\n    band_7 == \"1011\" ~ \"missing input\",\n    band_7 == \"1100\" ~ \"internal constant used\",\n    band_7 == \"1101\" ~ \"correction out of bounds\",\n    band_7 == \"1110\" ~ \"L1B data faulty\",\n    band_7 == \"1111\" ~ \"not processed due to deep ocean or clouds\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(atmospheric_correction = ifelse(bit_30 == 0, \"no\", \"yes\"),\n         adjacency_correction = ifelse(bit_31 == 0, \"no\", \"yes\"))\n```\n:::\n\n\n### state_1km proof of concept for\n\nHere, I'm going to apply the same process described above to the variable `state_1km`. This one needs just 16 bits, so there have to be some changes in the code indicating the quantity of bits to be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test with qc_500\n## Check unique values and add one validation (from the video)\nqc_data <- data.frame(qc_ints = c(unique(reflectance_500$state_1km),\n                                  1131675649))\n\n## Create empty data frame. This case is 32 given that the variable\n## `qc_500m` have 32 bits\nfor (i in c(15:0)) {\n  qc_data[, paste0(\"bit_\", i)] <- NA\n}\n\n# Loop for obtaining bit string from unique values in the variable\nz <- 1\nfor (i in qc_data$qc_ints) {\n  # print(i)\n  transformed <- as.integer(intToBits(i)[1:16])\n  qc_data[z, 2:17] <- transformed[16:1]\n  z <- z + 1\n}\n\n## Create test according to value in video\nprocess_test <- qc_data |> \n  filter(qc_ints == 1131675649) |>\n  select(-qc_ints) |>\n  unite(col = \"new\", bit_15:bit_0, sep = \"\") |> \n  pull() \n\nstopifnot(process_test == \"0000000000000001\")\n```\n:::\n\n\n## Create function for bit string conversion\n\nAt this point I have the skeleton of the code needed to create a function to be applied to the next variables. It has to take into account the variable and the number of bits to be used in the bit mask conversion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transform this to a function\nobtain_bit_qc_df <- function(variable, bits) {\n  \n  ## Check unique values and add one validation (from the video)\n  qc_data <- data.frame(qc_ints = c(unique(reflectance_500[[variable]]),\n                                    1131675649))\n  \n  ## Create empty data frame. This case is 32 given that the variable\n  ## `qc_500m` have 32 bits\n  total_bits = bits - 1\n  for (i in c(total_bits:0)) {\n    qc_data[, paste0(\"bit_\", i)] <- NA\n  }\n  \n  # Loop for obtaining bit string from unique values in the variable\n  bit_col <- bits + 1\n  z <- 1\n  for (i in qc_data$qc_ints) {\n    # print(i)\n    transformed <- as.integer(intToBits(i)[1:bits])\n    qc_data[z, 2:bit_col] <- transformed[bits:1]\n    z <- z + 1\n  }\n \n  ## Create test according to value in video\n  final_bit <- paste0(\"bit_\", total_bits)\n  \n  process_test <- qc_data |> \n    filter(qc_ints == 1131675649) |>\n    select(-qc_ints) |>\n    unite(col = \"new\", everything(), sep = \"\") |> \n    pull() \n  \n  test_object <- stringr::str_sub(\"01000011011101000000000000000001\",\n                                  start = -bits, end = -1)\n\n  stopifnot(process_test == test_object) \n  \n  return(qc_data)\n}\n```\n:::\n\n\n-   Test the function as first step to obtain the quality categories\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain the bit string\nqc_data_function <- obtain_bit_qc_df(variable = \"state_1km\", bits = 16)\n\n# Compare last qc_data from state_1km and new qc_data created with function\nstopifnot(qc_data$bit_14 == qc_data_function$bit_14)\n\n# Check dimensions\nstopifnot(dim(qc_data) == dim(qc_data_function))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the categories according to documentation\nstate_1km__description <- qc_data_function |> \n  unite(col = \"cloud_state\", c(\"bit_1\", \"bit_0\"), sep = \"\") |> \n  unite(col = \"land_water_flag\",\n        c(\"bit_5\", \"bit_4\", \"bit_3\"), sep = \"\") |>\n  unite(col = \"aerosol_quantity\",\n        c(\"bit_7\", \"bit_6\"), sep = \"\") |>\n  unite(col = \"cirrus_detected\",\n        c(\"bit_9\", \"bit_8\"), sep = \"\") |>\n  mutate(cloud_state_qa = case_when(\n    cloud_state == \"00\" ~ \"clear\",\n    cloud_state == \"01\" ~ \"cloudy\",\n    cloud_state == \"10\" ~ \"mixed\",\n    cloud_state == \"11\" ~ \"not set, assumed clear\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(cloud_shadow_qa = ifelse(bit_2 == 1, \"yes\", \"no\")) |> \n    mutate(land_water_qa = case_when(\n    land_water_flag == \"000\" ~ \"shallow ocean\",\n    land_water_flag == \"001\" ~ \"land\",\n    land_water_flag == \"010\" ~ \"ocean coastlines and lake shorelines\",\n    land_water_flag == \"011\" ~ \"shallow inland water\",\n    land_water_flag == \"100\" ~ \"ephemeral water\",\n    land_water_flag == \"101\" ~ \"deep inland water\",\n    land_water_flag == \"110\" ~ \"continental/moderate ocean\",\n    land_water_flag == \"111\" ~ \"deep ocean\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n    mutate(aerosol_quantity_qa = case_when(\n    aerosol_quantity == \"00\" ~ \"climatology\",\n    aerosol_quantity == \"01\" ~ \"low\",\n    aerosol_quantity == \"10\" ~ \"average\",\n    aerosol_quantity == \"11\" ~ \"high\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n    mutate(cirrus_detected_qa = case_when(\n    cirrus_detected == \"00\" ~ \"none\",\n    cirrus_detected == \"01\" ~ \"small\",\n    cirrus_detected == \"10\" ~ \"average\",\n    cirrus_detected == \"11\" ~ \"high\",\n    TRUE ~ \"No info, please validate bit conversion\"\n  )) |> \n  mutate(cloud_flag_qa = ifelse(bit_10 == 1, \"cloud\", \"no cloud\"),\n         fire_flag_qa = ifelse(bit_11 == 1, \"fire\", \"no fire\"),\n         snow_ice_flag_qa = ifelse(bit_12 == 1, \"yes\", \"no\"),\n         pixel_adjacent_cloud_qa = ifelse(bit_13 == 1, \"yes\", \"no\"),\n         salt_pan_qa = ifelse(bit_14 == 1, \"yes\", \"no\"),\n         snow_mask_qa = ifelse(bit_15 == 1, \"yes\", \"no\"))\n```\n:::\n\n\n### g_flags\n\nIt looks that this variable have just the same value for every observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(reflectance_500$gflags)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nGiven that I don't have any values there other than 0, I'm not going to apply the function to this variable.\n\n### q_scan\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain the bit string\nqc_data <- obtain_bit_qc_df(variable = \"q_scan\", bits = 8)\n\n# Create the categories according to documentation\nq_scan_description <- qc_data |> \n  mutate(scan_quadrant_1 = ifelse(bit_0 == 1, \"yes\", \"no\"),\n         scan_quadrant_2 = ifelse(bit_0 == 1, \"yes\", \"no\"),\n         scan_quadrant_3 = ifelse(bit_0 == 1, \"yes\", \"no\"),\n         scan_quadrant_4 = ifelse(bit_0 == 1, \"yes\", \"no\"),\n         missing_obs_1 = ifelse(bit_1 == 1, \"same\", \"different\"),\n         missing_obs_2 = ifelse(bit_1 == 1, \"same\", \"different\"),\n         missing_obs_3 = ifelse(bit_1 == 1, \"same\", \"different\"),\n         missing_obs_4 = ifelse(bit_1 == 1, \"same\", \"different\"))\n```\n:::\n\n\n## Conclusions on the bit mask conversion\n\n-   All steps and references are documented.\n-   I created a function to do the bit mask conversion\n-   Function will be exported to a new file and documented as a formal function in R to be used in the next steps for the data analysis.\n-   After using the function, steps to include the correspondent categories according to the official MODIS documentation are needed.\n-   The new data frames with the bit strings and the categories per each unique value will be used to filter the all the original observations from the datasets.\n-   All these are cleaned and written as a runtime process in the file `scripts/create_bitstrings_tables.R`. The outcome of this script will be used formally in the next steps of the research data analysis.\n\n## Quality filtering\n\nNow that I have validated the function and I have per each of the variables with bit mask the categories obtained from the MODIS documentation, I can start with filtering out those pixels with low quality.\n\n### Select bitmasks categories that indicates high quality\n\n-   First I will start with `state_1km`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# quality values from state_1km\n# bit 6-7 and bit 13 can be anything as regarded by richard\nstate_1km_highest_quality <- state_1km__description |>\n  filter(cloud_state_qa == \"clear\") |> \n  filter(cloud_shadow_qa == \"no\") |>\n  filter(land_water_qa == \"land\") |> \n  filter(cirrus_detected_qa == \"none\") |> \n  filter(bit_10 == \"0\") |> \n  filter(fire_flag_qa == \"no fire\") |> \n  filter(snow_ice_flag_qa == \"no\") |> \n  filter(bit_14 == \"0\") |> \n  filter(bit_15 == \"0\") |> \n  select(qc_ints) |> \n  pull()\n\nstate_1km_highest_quality\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8392  200  136    8   72 8264 8328\n```\n:::\n:::\n\n\n-   Filtering with `qc_500m`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# quality values from qc_500\n# All should be 0 for all of the bits, except for \nqc_500_highest_quality <- qc_500_description |>\n  filter(modland_qa == \"ideal quality - all bands\") |>\n  filter(band1_qa == \"highest_quality\") |>\n  filter(band2_qa == \"highest_quality\") |>\n  filter(band3_qa == \"highest_quality\") |>\n  filter(band4_qa == \"highest_quality\") |>\n  filter(band5_qa == \"highest_quality\") |>\n  filter(band6_qa == \"highest_quality\") |>\n  filter(band7_qa == \"highest_quality\") |>\n  filter(atmospheric_correction == \"yes\") |>\n  # filter(adjacency_correction == \"yes\") |> \n  select(qc_ints) |> \n  pull()\n\nqc_500_highest_quality\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1073741824\n```\n:::\n:::\n\n\n-   Filtering with q_scan\n\nFrom the meeting with Richard Fernandes, we agreed to leave this one out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# quality values from q_scan\n# This one is fine if I don't use it and let it be.\n```\n:::\n\n\n-   Filtering with gflags\n\nFor the `reflectance_500` dataset, we have the same value in all the observations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# quality values for gflags\n# gflags_highest_quality <- reflectance_500 |>\n#   filter(gflags == 0)\n```\n:::\n\n\n### Filter from complete data the selected bitmasks\n\nSo far, I have the bitmasks that indicates the highest quality, so I can filter out the rest from the `reflectance_500` dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_1km_filter <- reflectance_500 |> \n  filter(state_1km %in% state_1km_highest_quality) |> \n  nrow()\n\nstate_1km_filter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4586\n```\n:::\n:::\n\n\nThose number of observations represents just the filtering based on the `state_1km` variable. Now, I will continue with the `qc_500` variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_1km_filter_qc_500 <-reflectance_500 |> \n  filter(state_1km %in% state_1km_highest_quality) |> \n  filter(qc_500m %in% qc_500_highest_quality) |> \n  nrow()\n\nstate_1km_filter_qc_500\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4319\n```\n:::\n:::\n\n\n## Some plots with clean reflectance_500 data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreflectance_500 |> \n  filter(state_1km %in% state_1km_highest_quality) |> \n  select(date) |> \n  # pull() |> \n  mutate(year_month = zoo::as.yearmon(date)) |> \n  ggplot(aes(x = date)) + \n  geom_histogram() +\n  scale_x_date(date_labels = \"%b%Y\", breaks = \"months\") +\n  theme(axis.text.x = element_text(angle = 90, h = 1)) +\n  labs(x = \"Date\",\n       y = \"Number of pixels\",\n       title = \"Borden  MODIS pixels per month after quality filtering\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n## Conclusion\n\n-   Function `obtain_bit_qc_df()` can be used to do the bit string conversion\n-   All steps are summarized in the function. Code here is just the historical reference. Functional and documented code for the function is in the `R/create_bit_string.R` file.\n-   The code to create the human readable categories from the bit strings so that bad/high quality filtering of the pixels can be done in the analysis is in the `scripts/create_bitstrings_tables.R`.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}