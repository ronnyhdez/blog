[
  {
    "path": "posts/2021-12-11-usingmkdocsrmd/",
    "title": "Using mkdocs and Rmarkdown",
    "description": "A how-to blog post on how to use mkdocs and Rmarkdown to create cool documentation.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2021-12-11",
    "categories": [],
    "contents": "\nDistill is a publication format for scientific and technical writing, native to the web.\nLearn more about using Distill at https://rstudio.github.io/distill.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-12-11T12:53:10-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-desplegando-shiny/",
    "title": "Desplegando mi app de shiny con shiny-server",
    "description": "Si hemos creado una aplicación de shiny, es muy probable que hayamos disfrutado el verla corriendo en nuestro computador y de pronto nos preguntemos: ¿Cómo puedo abrir mi aplicación al mundo? ¿Cómo otras personas pueden acceder y usar a mi aplicación? ¿Cómo compartir mi aplicación con usuarios sin que tengan que instalar R, RStudio y poner al correr mi código? Bueno, pues esto es lo que conocemos como desplegar una aplicación. Vamos a \"llevar a internet\" nuestra aplicación y hacerla accesible al mundo.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2020-12-28",
    "categories": [],
    "contents": "\n¿Porqué necesito saber esto?\nSi hemos creado una aplicación de shiny, es muy probable que hayamos disfrutado el verla corriendo en nuestro computador y de pronto nos preguntemos:\n¿Cómo puedo abrir mi aplicación al mundo? ¿Cómo otras personas pueden acceder y usar a mi aplicación? ¿Cómo compartir mi aplicación con usuarios sin que tengan que instalar R, RStudio y poner al correr mi código?\nBueno, pues esto es lo que conocemos como desplegar una aplicación. Vamos a “llevar a internet” nuestra aplicación y hacerla accesible al mundo.\nCuando menciono “hacerla accesible al mundo”, hablo de que podamos compartir un enlace y cualquier persona que dé click en ese enlace llegará a ver la interfaz de nuestra aplicación.\n¿Qué esperar de esta guía?\nTodos los pasos con instrucciones en bash para desplegar una aplicación de shiny con shiny server open source en un servidor Linux con Ubuntu\nEl objetivo es mostrar los pasos para instalar los elementos necesarios en un servidor y que se pueda desplegar el app.\nNo se muestran los pasos para levantar el servidor. Esto queda a preferencia de cada quién y con el proveedor de su elección.\nTampoco se muestra en la guía los pasos para definir el dominio que potencialmente puede dirigir a la aplicación.\nRequisitos:\nPara poder seguir la guía, es necesario que ya haya desarrollado una aplicación de shiny. Puede seguir los pasos acá indicados haciendo uso de la aplicación modular que presenté en los webinarios de DataLatam\nAsí mismo es necesario contar con un servidor en el que pueda desplegar la aplicación.\nTambién necesitamos tener conocimiento de git. La guía muestra los pasos haciendo uso de esta herramienta.\nRecomendaciones del servidor:\nComo mínimo es recomedanble levantar un servidor con las siguientes características:\nMemoria: 16 Gb\nCPU: 4\nDisco: 20\nOS: Ubuntu mayor a 18.04.4 LTS\nPasos\nSi ya tenemos un servidor, vamos a proceder con los siguientes instrucciones:\n1- Instalando R en el servidor:\nPara evitar inconvenientes de versiones desactualizadas de R, podemos seguir las siguientes instrucciones:\n\n\n\n2- Instalando librerías linux comunes para R en el servidor\n\n\n\nLuego tomamos un paso para asegurarnos que todos los paquetes de Ubuntu se encuentren actualizados en el servidor\n\n\n\n3- Instalando shiny server\nAntes de iniciar con la instalación de shiny server, debemos de instalar el paquete de R shiny:\n\n\n\nPara seguir la instalación de shiny server primero hay que instalarle a la máquina gdebi\n\n\n\nLuego en la pagina de shiny server copiamos la direccion de donde tienen la última version.\nDebemos de asegurarnos de obtener la versión más actualizada. La instrucción acá mostrada puede quedar desactualizada.\nLa versión la validamos con el número que aparece luego de la palabra shiny-server En este caso, la usada para la guía es (shiny-server-1.5.13.944)\n\n\n\nUna vez instalado podemos revisar el estado de shiny-server:\n\n\n\nPare reiniciar el servidor de shiny cuando tenemos problema:\n\n\n\nUna vez que tenemos instalado shiny-server,vamos a revisar por la puerta que está sirviendo. Podemos tomar la dirección IP externa del servidor, copiarla en el navegador (yo tengo preferencia por firefox) y de seguido escribimos : y la puerta 3838 (Por defecto, la que sirve shiny)\n\n\n\nSi no tenemos un servicio disponible (no vemos una página funcionando) debemos de revisar las reglas firewall del servidor e indicarle la salida del app.\n4- Llevando la aplicación al servidor\nA este punto tenemos nuestro servidor con R instalado, con shiny-server funcionando y las principales librerías linux para usar con una aplicación de shiny. Ahora el paso que sigue es llevar nuestra aplicación de shiny al servidor.\nEs aquí donde usaremos git. Lo haremos con mi aplicación de ejemplo que se encuentra en github\nDentro del servidor, las aplicaciones deben de estar bajo el siguiente directorio:\n/srv/shiny-server\nAllí es donde debemos de llevar nuestra aplicación.\n\n\n\nLuego, necesitamos instalar en el servidor los paquetes que son necesarios para nuestra aplicación. Todos aquellos paquetes que hayamos usado necesitamos incluirlos. Si dejamos alguno por fuera es muy probable que nuestra aplicación no levante. (Es el error más común que cometo)\nHay dos maneras de realizar este paso. Uno es dando el comando desde bash y el otro es abrir una sesión de R como usuario root e instalarlo tal cual lo haríamos en una sesión de R en nuestro computador:\n\n\n\nSi hay algún paquete que no está en el CRAN porque es una versión en desarrollo, podemos echar mano del paquete remotes (el cual debimos de incluir en el paso anterior)\n\n\n\n5- Levantando la aplicación\nCon todos los pasos anteriores listos, procedemos a detener y volver a iniciar el servicio de shiny-server, para luego probar si nos podemos conectar a ella:\n\n\n\nSi el servicio está activo, podemos probar con la IP externa, la puerta 3838 e indicamos el nombre de la aplicación. Debería de ser algo similar a: ip:3838/shiny_modular/\n¡Y listo! Con esto tenemos los pasos básicos para desplegar nuestra aplicación de shiny en nuestro servidor y hacerla disponible al mundo.\nReferencias\nEl resumen de pasos mostrados en esta guía han sido tomados y adaptados de diversas fuentes como:\nDigitalOcean (Algún día lograré documentar como lo hacen ellos)\nShiny Server Professional v1.5.15 Administrator’s Guide El sitio a visitar cuando hay problemas con shiny-server. Es documentación técnica\n\n\n\n",
    "preview": {},
    "last_modified": "2021-12-11T13:28:28-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-otra-intro-a-git/",
    "title": "Otra introducción a git",
    "description": "Una introducción al control de versiones con git (otra más).",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2016-04-20",
    "categories": [],
    "contents": "\n¿Qué resuelve git? ¿Porqué usar git?\nSi les ha sucecido que luego de trabajar en un documento, tienen una carpeta llena con nombres como: “version_final”, “version_final_final”, “version_final_corregida”, “version_final_revisada” pues git les será útil para tener un control sobre los cambios que se introducen en el documento.\nEn este tutorial haremos ejemplos con scripts de código en R y cómo los cambios que vayamos trabajando, los podemos registrar, usar, guardar y documentar con mayor eficiencia tanto para trabajar individualemente como grupalmente.\n\nEsquema de git\nAqui pretendo aclarar rapidamente que vamos a hacer con git, tener el bosquejo antes de entrar en detalles. Vamos a tener un repositorio remoto o en inglés upstream que será nuestro repositorio en github/gitlab/bitbucket. De este repositorio tendremos uno local que crearemos al hacer el clon. Siempre vamos a trabajar en repositorio local (en nuestra computadora) y esos cambios los vamos a subir al remoto con un push. De igual manera cambios que existan en el repositorio remoto (porque alguien hizo una contribucion, trabajamos desde otra computadora ys ubimos los cambios) lo vamos a hacer con un pull.\nVamos a tener una rama principal llamada master. El consejo aca es tener código limpio y funcional. Todo lo que sea trabajo en desarrollo, experimentos, pruebas o tareas específicas, vamos a hacerlo en ramas. Las ramas van a tener el nombre que nosotros decidamos. Los cambios que se encuentran en estas ramas, una vez que se encuentran finalizados, revisados y funcionales los podremos integrar a nuestra rama master en un proceso conocido como merge\nCada vez que hagamos cambios en el código, vamos a hacer un commit. Esto lo podemos interpretar como marcar un punto en la historia del proyecto. Git nos mostrará información sobre cada uno de nuestros commits tal como la fecha, hora, usuario, archivos cambiados y las líneas de los archivos que se cambiaron. La idea de los commits es que siempre podamos retornar a un punto específico en la historia del proyecto.\nEn el caso de trabajar con el repositorio de alguien más, lo podemos realizar a través de un proceso que se conoce como fork, que no es más que una bifurcación del repositorio de esa persona. Al realizar un “fork” del repositorio de otra persona estamos creando una copia de dicho repositorio bajo nuestro usuario. Ahora bien, la manera de ofrecer los cambios que hemos trabajado a la persona dueña del repositorio tiene un proceso algo diferente que veremos en otro tutorial.\nIniciar con git\nEn este segmento vamos a seguir los pasos para tener un repositorio que tenga su cuenta remota con github/gitlab/bitbucket y local a través de nuestra terminal.\n1. Crear repositorio en github/gitlab/bitbucket\nSi tenemos cuenta en github/gitlab/bitbucket podemos crear un repositorio. Le llamamos repositorio al sitio donde vamos a guardar nuestros archivos. Un repositorio lo podemos visualizar como una carpeta que contendrá nuestro trabajo.\nCuando se crea un nuevo repositorio lo recomendable es iniciarlo con un arhivo que se llama .gitignore y con un readme. Para hacerlo en github (y algo similar en otras plataformas) es que seleccionemos las opciones de iniciar repositorio con un archivo .gitignore y un readme. El archivo gitignore debe de ser específico para la herramienta que vayamos a usar, en este caso sería R \nLa funcionalidad del .gitignore es que este archivo (es como un archvio de texto) contiene especificaciones sobre los formatos de los archivos que no queremos que se integren en nuestro sistema de control de versiones. Generalmente no deseamos que archivos como imagenes (.png .jpeg) o bien archivos de datos muy grandes (.txt .csv .feather) sean compartidos entre repositorios remotos, locales o personas con las que colaboremos. Un ejemplo de un archivo .gitignore es el siguiente:\n\nSi no identifican algunos de los elementos de ahí no hay de qué preocuparse, mejor nos enfocámos en los tipos de archivos que nosotros necesitamos que NO sean tomados en cuenta por git, es decir, que no queremos que se suban a nuestro repositorio de github por ejemplo ni en la gestión de versiones. Si es el caso que tenemos que hacer el knit de un Rmarkdown y necesitamos un archivo .csv para renderizarlo, pero solamente queremos el archivo Rmakrdown en el sistema de git, pues en nuestro archivo .gitignore escribimos .csv, guardamos el archivo y listo.\nEn el caso del readme es un archivo que debe de dar una idea de qué tenemos en el repositorio. Es una guía para nosotros mismos u otros usuarios que vayan a hacer uso del repositorio y nuestro código. En github los readme se ven así:\n\nUna vez que el repositorio haya sido creado, vamos a encontrarnos con una opción que dirá “clone or download”. Vamos a hacer click en clone y la dirección que allí sale la tenemos que copiar (ctrl + c). La imagen muestra lo que sucede al hacer clone en el botón verde que ofrece github:\n\nYa con la información de la dirección del repositorio copiada, vamos a llevarla a nuestra terminal:\n2. Clonar repositorio en nuestra computadora\nUna vez que tenemos creado el repositorio y la dirección copiada, vamos a abrir nuestra terminal. Si es usuario de windows puede usar el powershell. Lo primero que vamos a ver es una dirección y allí tendremos que dirigirnos a la carpeta donde deseamos colocar el repositorio.\n\ncd ~ #Esto me va a llevar al home\n\n\ncd Desktop/ #Me lleva al escritorio\n\n\nls #Me da lista de los elementos que existen en la dirección que estoy\n\n\ncd primeras_letras_nombre <TAB> #Con TAB autocompleta el nombre\n\nEste procedimiento lo vamos realizando hasta llegar a la carpeta en la cual queremos clonar el repositorio.\nEl segundo paso es clonar el repositorio:\n\ngit clone <dirección del repositorio que copiamos>\n\nPor último nos dirigimos a la carpeta del repositorio\n\ncd <nombre_repositorio>\n\n¡Listo! Ya tenemos el repositorio remoto tal cual en nuestra computadora local. A partir de aquí podemos trabajar en nuestros archivos.\n3. Crear una rama en el repositorio\n¿Qué pasa si queremos hacer una variación en el código sin miedo a dañar lo que ya tenemos? Pues bien, git nos permite hacer ramas que son una bifurcación del trabajo que llevamos realizado hasta ese momento y que si luego queremos, podemos volver a integrar a la rama principal.\nCuano tenemos un repositorio la rama principal está nombrada como master. A partir de esta rama master podemos hacer ramas con los nombres que nosotros queramos. La idea de las ramas es trabajar de manera ordenada, en donde en mi rama master siempre debemos de tener código limpio y funcional y lo que sean nuevas tareas, mejoras o experimentos lo hagamos en ramas que se bifurcan a partir de la rama master.\nCuando el trabajo realizado en la rama sea funcional y limpio, lo podemos integrar a la rama master. Caso contrario podemos olvidarnos de la rama y volver a nuestra rama master.\nCrear rama\n\ngit checkout -b <NOMBRE_RAMA> #Nos crea y dirige a la nueva rama\n\nVerificar rama en la que estamos\n\ngit status\n\ncambiar entre ramas\nPara cambiar entre ramas que ya existen NO hay que usar “-b”\n\ngit checkout <NOMBRE_RAMA>\n\n4. Subir/bajar cambios\nComo estamos trabajando con un repositorio remoto y uno local, vamos a querer sincronizar los cambios. Estos cambios pasarán a estar en la historia del proyecto como commits. Un commit es un punto en la historia del proyecto que muestra el trabajo realizado en ese momento. En el flujo del trabajo que uno tenga es recomendable hacer commits regularmente y hacer el push de manera regular para asegurarnos de no perder el trabajo.\n4.1 Revisar estado de los cambios  Cuando tengamos cambios en nuestros archivos, podemos revisar cuáles han cambiado y si los tenemos incluidos o no en nuestro registro de cambios\n\ngit status\n\n4.2 Agregar cambios Los archivos que queramos agregar a la historia del proyecto lo podemos hacer de dos maneras, una donde indicamos explícitamente el archivo específico:\n\ngit add <NOMBRE_ARCHIVO>\n\nO de tal manera en que agreguemos todos los archivos con cambios de una vez\n\ngit add .\n\n4.3 Someter cambios a la historia de git\n\ngit commit -m \"MENSAJE_CORTO\"\n\nEl mensaje sirve para darnos a nosotros mismos o a colaboradores, una idea del cambio que se trabajó.\n4.4 Subir cambios al repositorio remoto\n\ngit push\n\n4.5 Bajar cambios del repositorio remoto Si estamos trabajando con colaboradores y han integrado cambios en el repositorio remoto que nosotros no tenemos en nuestro repositorio local, los podemos traer de la siguiente manera:\n\ngit pull\n\n¿Qué tenemos hasta acá?\nUna idea básica sobre git, de sus componentes, del flujo de trabajo y de los principales comandos que se usan. Un tutorial con un ejemplo básico vendrá despueś.\nReferencias\nhttps://git-scm.com/book/en/v2 https://git-scm.com/book/es/v1/Ramificaciones-en-Git-Procedimientos-b%C3%A1sicos-para-ramificar-y-fusionar\n\n\n\n",
    "preview": {},
    "last_modified": "2021-12-11T13:38:11-07:00",
    "input_file": {}
  }
]
