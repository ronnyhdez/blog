[
  {
    "path": "posts/2021-12-11-usingmkdocsrmd/",
    "title": "Creating a website using mkdocs, Rmarkdown and GitHub pages",
    "description": "A posible solution for note takers (and those who need to organize your documentation) with mkdocs and Rmarkdown.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2022-01-13",
    "categories": [],
    "contents": "\nWhat are we going to create?\nA static web page like this one to manage your documentation created in Rmarkdown\nThe problem:\nPretty often I found myself in situation where I say: “I did this sometime ago and now I don’t remember quite well which were the steps to do it again”.\nFrom my job and also current projects I’m always taking raw notes in a text file file and despite the tons of apps out there, I like text files because they are pretty simple and this allows me to just focus in writing down the idea, concept or steps of what I’m doing and implement markdown.\nBut, the problem with this approach is that at the end of the day, I have my desktop or other folders with a lot of individual .md or txt files laying around without any intuitive context. This got me in troubles and in loosing time when I wanted to get back to something that I did and that I had somewhere in my computer.\nIf at this point your are asking yourself: why you didn’t use a wiki? or a vignette? or an Rmarkdwon file? or something more organized? The answer is simple: In the middle of a project execution, when I doubt about something, I would go to google or a reference book, grab what I needed and take a quick note about the steps that I followed to accomplish my task. If it didn’t work I would throw away the file, if it worked, I would keep the file.\nThen, I found out about MkDocs (actually Frans was who showed me this) and it was the perfect solution: a simple web page, an index and most important: a search toolbar that can search in all the web page content (I mean, all my notes in there)!\n\nAs they state in their site:\n\nMkDocs is a fast, simple and downright gorgeous static site generator that’s geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file.\n\nNow, they state that source files are written in Markdown, but if I’m an R user, probably I’m used to Rmarkdown files. Plus it’s nice to create documents in Rmarkdown where I can mix markdown and R code (R + markdown).\nSo, how can I set up everything?\nFor this recipe, you will need:\nR and RStudio\nRmarkdown package\nMkDocs\ngit\nGitHub account\nI’m not going to describe how to install R RStudio, Rmarkdown or git. There are plenty good tutorials and documentation on how to do it out there. I’m going to describe the process from the installation of MkDocs.\nGetting MkDocs\nFor this, I followed the instructions over here. I got already python on my machine and I’m a Linux user, so I’m using Ubuntu 20.04\nGiven that I had already python I just installed MkDocs:\n\npip install mkdocs\n\nThen I validated that the installation was succesful:\n\n$ mkdocs --version\nmkdocs, version 1.2.2 from /home/your_username/.local/lib/python3.8/site-packages/mkdocs (Python 3.8)\n\nDone! I got MkDocs on my computer.\nGetting Matherial theme\nI don’t like the default theme that comes with MkDocs, so I changed to Matherial.\nTo install this theme, you will need to run in the terminal:\n\n$ pip3 install mkdocs-material\n\nConfiguring your GitHub repository\nYou will need to have an account already on GitHub. When you are done with this step, you can go and create a repository. Also you will need to go to settings, search for Pages on the left hand side menu and there select the main branch to enable GitHub Pages for your repository.\nThe steps are the following:\nCreate a new repository\n\nOptions for the new repo\n\nSettings to enable GitHub pages\n\nCloning your project\nIf you are already familiar with this step, skip this section and go ahead to the next session. If you are starting with git and GitHub here is the set of steps to clone your repo and start working.\nUp to this point we just have created the repository on GitHub and tweak some settings. It’s time to clone the repository created on GitHub to our computer. We will be working with the RStudio IDE.\nCreate new project\nSelect the Version Control option \nThen select the Git option \nNow, go to your repository on GitHub and under the Code button copy the url. Make sure that the HTTPS option is highlighted. \nCopy the URL in the Repository URL section. The Project directory name should auto-populate. Then select your path where you want to locate your repository folder. \nNow, RStudio should open a new session for working on your repository!\nWorking on your notes\nNow we are all set. We can start creating our Rmarkdown documents:\n\nCreate as many Rmd documents as you need. Each document will be a “section” on your final website.\nEach of the titles and subtitles in your document will be sections inside the specific page.\nAlso, use relative paths. This will make everything less error prone.\nNow, because we are going to use the package docmaker we need to follow a structure:\nAll your Rmd files should be in the root of your project.\nYour data, images, pdfs files can be saved inside folders.\nDon’t use docs folder. This is a special folder designated to save the files needed to build the web page. docmaker package will be in charge of the use of this folder, so you don’t have to worry about it.\nYour files in your repository should look something like this:\n\n.gitignore advice\nIn order to not make your control version slow or run out of space in your GitHub account, ignore some files writting them in your .gitignore file.\nJust open that file in RStudio and add the following lines to not include images, data, credentials or other files that are not necessary for control versioning:\n\nIn there I added:\n# Personal files\ndata/\nimages/\n*.html\n.Renviron\nSending your changes to your github repository.\nFor this example I’m not using branches to avoid focusing on the git details, so we are just going to send everything to the main branch. This step is\n\ngit add .\ngit commit -m \"Add first notes\"\ngit push\n\nBe aware that this is probably going to ask you for who you are (user name on GitHub and email) and your credentials. One tip to save your credentials for the specific repository that you are working on is the following command after you enter your credentials:\n\ngit config credential.helper store\n\nDeploy and publish your notes with docmaker\nSo far, we have our notes. But we are still lacking the part of publishing in our web page the notes. There are several steps to do this manually but after many times repeating everything I decided to create a small R package to automatize this steps. This package is called dockmaer\nYou can install the package with:\n\n\ndevtools::install_github(\"ronnyhdez/docmaker\")\n\n\n\nNow, on your console you can load the package:\n\n\nlibrary(docmaker)\n\n\n\nConfigure repo with docmaker\nBefore building and deploying our notes, we need to do some configuration steps in our repository. docmaker can take care of this with the function:\n\n\nbuild_repo(github_page_url = \"https://ronnyhdez.github.io/test_docmaker/\",\n           site_author = \"Ronny A. Hernández Mora\")\n\n\n\nWe can get the URL of our repository in the settings > page on GitHub. After we enabled this in a step before, there should appear the URL designated by GitHub for our web site.\n\nThe site_author should be our name.\nThis function will do the following:\nCreate a yml file\nAdd to the .gitignore the site folder\nCreate a docs folder\nBuild and deploy notes\nBecause this is our first time, all of our notes (three in the example) are not existing as md documents nor even built or deploy with mkdocs.\ndocmaker have a function to take all the .Rmd files existing in our project root and do all the steps needed to deploy this ones:\n\n\nmake_all_docs(deploy = TRUE)\n\n\n\nThis function will do the following:\nRender all our Rmd files to md\nMove the outputs (including images) to the docs folder\nIf we are using a README.Rmd file this will be ignore\nBuild the mkdocs\nIf deploy is set to TRUE it will deploy the notes.\nCreate an specifi branch for the pages deployment: gh-deploy\nNow, given that we are using a new branch to be deployed, we need to go back to GitHub pages and make a small change: change the branch selected to be build from:\n\nAfter some seconds (or a few minutes), we should be able to see our site alive!\n\nAs we can see, our 3 files are sections in the left side menu. The titles and subtitles of each document will be shown in the Table of contents in the right side menu.\nCode and example site\nAll the code and configuration files of the example site are in this GitHub repository:\nRepository\nSite\n\n\n\n",
    "preview": "posts/2021-12-11-usingmkdocsrmd/images/site_alive.png",
    "last_modified": "2022-01-13T15:39:04-07:00",
    "input_file": "usingmkdocsrmd.knit.md"
  },
  {
    "path": "posts/2021-12-11-usando-tmux/",
    "title": "Usando tmux: apuntes breves de mi jornada",
    "description": "Breves notas sobre el uso de tmux. Adecuado para mirar de manera rápida alguna instrucción que necesitemos para continuar con nuestro flujo de trabajo.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\n¿Qué es tmux?\nEs un sistema de multiplexación para sistemas Unix. Lo que nos permite es realizar múltiples tareas en una terminal a través del uso de paneles, sesiones o ventanas.\nEn otras palabras, es abrir una terminal y poder abrir y usar otras terminales dentro de esta.\nInstalando tmux\nPara instalarlo en distribuciones basadas en debian, podemos hacerlo con el comando:\n\nsudo apt install tmux\n\nPara validar que se instaló\n\n# Si nos da un número de version, estamos listos.\ntmux -V\n\nPrimeros pasos con tmux\nPara iniciar la sesión con tmux, corremos en la terminal el comando con el mismo nombre:\n\ntmux\n\nVeremos en la parte inferior de la terminal que tenemos información como\n\n[0] 0:bash*    \"ronny\" 22:35 03-ene-21\n\nCon esto podemos asegurar que estamos usando tmux sin problema.\nPara hacer uso de las funciones que trae tmux, necesitamos tener en cuenta que hay un prefijo configurado por defecto que hay que utilizar para la mayoría de las operaciones: ctrl + b\nEsto se puede configurar para no dejarlo en una combinación de teclas tan incómoda, pero lo haremos luego.\nPaneles en tmux\nEn la terminal podemos dividir la vista en varios paneles.\nSe pueden dividir paneles en otros más.\nCada panel puede ejecutar distintas tareas.\nDividir paneles horizontal\n\nctrl + b + \"\n\nDividir paneles vertical\n\nctrl + b + %\n\nCerrar un panel\n\n# Primera opción\nctrl + b + x\n\n# Segunda opción:\nexit\n\nMoverse entre paneles\n\nctrl + b + ← ↑ → ↓ \n\nZoom en un panel\nSobre el panel que queremos enfocarnos usamos el comando.\nLos demás paneles no desaparecen, quedan ocultos por el panel en zoom.\nCon el mismo comando quitamos el enfoque en el panel\n\n# Para hacer el enfoque en un panel\nctrl + b + z\n\n# Para quitar el enfoque, en el panel escribimos el mismo comando\nctrl + b + z\n\nVentanas en tmux\nA diferencia de los paneles, las ventanas nos dan una pantalla completa.\nPodemos generar varias ventanas y en cada ventana crear paneles.\nEn parte inferior de la terminal, tendremos info sobre la o las ventanas.\nCrear ventana\n\n# c = create\nctrl + b + c\n\nMoverse a ventana anterior\n\n# p = previous\nctrl + b + p\n\nMoverse a ventana siguiente\n\n# n = next \nctrl + b + n\n\nMoverse a ventana por id numérico\n\nctrl + b + numero_ventana\n\nCerrar una ventana\n\nctrl + b + &\n\nRenombrar ventana\n\n# Para abrir opción de renombrar\nctrl + b + ,\n\nSesiones en tmux\nCada vez que usamos el comando tmux abrimos una sesión.\nSi se cierra la terminal, podemos regresar a la sesión.\nLas sesiones pueden correr como proceso “oculto”\nDesconectarse de una sesión\n\nctrl + b + d\n\nRevisar sesiones de tmux abierta con bash\n\nps aux | grep tmux\n\nRevisar sesiones tmux con funcionalidad propia\n\n# Comando completo\ntmux list-sessions\n\n# Comando corto\ntmux ls\n\nConectarnos a una sesión en específico\n\n# Por ejemplo a sesión 1\ntmux attach -t 1\n\nCambiar nombres a sesiones\n\n# Dentro de la sesión\nctrl + b + $\n\nCrear una nueva sesión con nombre\n\ntmux new -s \"mi_proyecto\"\n\nHojas de referencia\nExisten hojas de referencias para tmux. Una es esta\n\n\n\n",
    "preview": "posts/2021-12-11-usando-tmux/images/tmux.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-desplegando-shiny/",
    "title": "Desplegando mi app de shiny con shiny-server",
    "description": "Vamos a \"llevar a internet\" nuestra aplicación y hacerla accesible al mundo.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2020-12-28",
    "categories": [],
    "contents": "\n¿Porqué necesito saber esto?\nSi hemos creado una aplicación de shiny, es muy probable que hayamos disfrutado el verla corriendo en nuestro computador y de pronto nos preguntemos:\n¿Cómo puedo abrir mi aplicación al mundo? ¿Cómo otras personas pueden acceder y usar a mi aplicación? ¿Cómo compartir mi aplicación con usuarios sin que tengan que instalar R, RStudio y poner al correr mi código?\nBueno, pues esto es lo que conocemos como desplegar una aplicación. Vamos a “llevar a internet” nuestra aplicación y hacerla accesible al mundo.\nCuando menciono “hacerla accesible al mundo”, hablo de que podamos compartir un enlace y cualquier persona que dé click en ese enlace llegará a ver la interfaz de nuestra aplicación.\n¿Qué esperar de esta guía?\nTodos los pasos con instrucciones en bash para desplegar una aplicación de shiny con shiny server open source en un servidor Linux con Ubuntu\nEl objetivo es mostrar los pasos para instalar los elementos necesarios en un servidor y que se pueda desplegar el app.\nNo se muestran los pasos para levantar el servidor. Esto queda a preferencia de cada quién y con el proveedor de su elección.\nTampoco se muestra en la guía los pasos para definir el dominio que potencialmente puede dirigir a la aplicación.\nRequisitos:\nPara poder seguir la guía, es necesario que ya haya desarrollado una aplicación de shiny. Puede seguir los pasos acá indicados haciendo uso de la aplicación modular que presenté en los webinarios de DataLatam\nAsí mismo es necesario contar con un servidor en el que pueda desplegar la aplicación.\nTambién necesitamos tener conocimiento de git. La guía muestra los pasos haciendo uso de esta herramienta.\nRecomendaciones del servidor:\nComo mínimo es recomedanble levantar un servidor con las siguientes características:\nMemoria: 16 Gb\nCPU: 4\nDisco: 20\nOS: Ubuntu mayor a 18.04.4 LTS\nPasos\nSi ya tenemos un servidor, vamos a proceder con los siguientes instrucciones:\n1- Instalando R en el servidor:\nPara evitar inconvenientes de versiones desactualizadas de R, podemos seguir las siguientes instrucciones:\n\n# Agregamos llave\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 \n\n# Agregamos repositorio\nsudo add-apt-repository 'deb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/'\n \n# Si estamos con ubuntu 20 el repositorio es:\nsudo add-apt-repository 'deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/'\n\n# Si queremos remover el repo no hacerlo a mano y usar el siguiente:\nsudo add-apt-repository --remove 'deb https://cloud.r-project.org/bin/linux/ubuntu focal-cran40/'\n\n# Actualizamos paquetes Ubuntu\nsudo apt update\n\n# Instalamos R\nsudo apt install r-base\n\n# Verificamos que versión de R sea la 4.0.1 (o las más actualizado al momento\n# de la instalación) \nR --version\n\n2- Instalando librerías linux comunes para R en el servidor\n\nsudo apt install libxml2-dev\nsudo apt install libssl-dev \nsudo apt install libcurl4-gnutls-dev \nsudo apt-get install unixodbc unixodbc-dev\n\nLuego tomamos un paso para asegurarnos que todos los paquetes de Ubuntu se encuentren actualizados en el servidor\n\nsudo apt update\nsudo apt upgrade\nsudo apt autoremove\n\n3- Instalando shiny server\nAntes de iniciar con la instalación de shiny server, debemos de instalar el paquete de R shiny:\n\nsudo su - \\\n-c \"R -e \\\"install.packages('shiny', repos='https://cran.rstudio.com/')\\\"\"\n\nPara seguir la instalación de shiny server primero hay que instalarle a la máquina gdebi\n\nsudo apt-get install gdebi-core\n\nLuego en la pagina de shiny server copiamos la direccion de donde tienen la última version.\nDebemos de asegurarnos de obtener la versión más actualizada. La instrucción acá mostrada puede quedar desactualizada.\nLa versión la validamos con el número que aparece luego de la palabra shiny-server En este caso, la usada para la guía es (shiny-server-1.5.13.944)\n\n# Damos dirección de donde traemos la descarga\nwget https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-1.5.13.944-amd64.deb\n\n# Procedemos con la instalación\nsudo gdebi shiny-server-1.5.13.944-amd64.deb\n\nUna vez instalado podemos revisar el estado de shiny-server:\n\nsudo systemctl status shiny-server\n\nPare reiniciar el servidor de shiny cuando tenemos problema:\n\nsudo systemctl restart shiny-server \n\nUna vez que tenemos instalado shiny-server,vamos a revisar por la puerta que está sirviendo. Podemos tomar la dirección IP externa del servidor, copiarla en el navegador (yo tengo preferencia por firefox) y de seguido escribimos : y la puerta 3838 (Por defecto, la que sirve shiny)\n\nip_externa_del_servidor:3838\n\nSi no tenemos un servicio disponible (no vemos una página funcionando) debemos de revisar las reglas firewall del servidor e indicarle la salida del app.\n4- Llevando la aplicación al servidor\nA este punto tenemos nuestro servidor con R instalado, con shiny-server funcionando y las principales librerías linux para usar con una aplicación de shiny. Ahora el paso que sigue es llevar nuestra aplicación de shiny al servidor.\nEs aquí donde usaremos git. Lo haremos con mi aplicación de ejemplo que se encuentra en github\nDentro del servidor, las aplicaciones deben de estar bajo el siguiente directorio:\n/srv/shiny-server\nAllí es donde debemos de llevar nuestra aplicación.\n\n# Nos cambiamos al directorio\ncd /srv/shiny-server\n\n# Clonamos el repositorio que contiene la aplicación\ngit clone https://github.com/ronnyhdez/shiny_modular.git\n\nLuego, necesitamos instalar en el servidor los paquetes que son necesarios para nuestra aplicación. Todos aquellos paquetes que hayamos usado necesitamos incluirlos. Si dejamos alguno por fuera es muy probable que nuestra aplicación no levante. (Es el error más común que cometo)\nHay dos maneras de realizar este paso. Uno es dando el comando desde bash y el otro es abrir una sesión de R como usuario root e instalarlo tal cual lo haríamos en una sesión de R en nuestro computador:\n\n# Con comando de bash\nsudo su - \\\n-c \"R -e \\\"install.packages(c('shiny', 'tm', 'SnowballC', 'wordcloud',\n'shinydashboard', 'RColorBrewer', 'ggplot2', 'purrr', 'nycflights13', 'dplyr'), repos='https://cran.rstudio.com/')\\\"\"\n\nSi hay algún paquete que no está en el CRAN porque es una versión en desarrollo, podemos echar mano del paquete remotes (el cual debimos de incluir en el paso anterior)\n\n# Ejemplo de instalación de paquete en desarrollo:\nsudo su - \\\n-c \"R -e \\\"remotes::install_github(\"datastorm-open/shinymanager\", \nforce = TRUE)\n\n5- Levantando la aplicación\nCon todos los pasos anteriores listos, procedemos a detener y volver a iniciar el servicio de shiny-server, para luego probar si nos podemos conectar a ella:\n\n# Reiniciar el servicio de manera recomendada:\nsudo systemctl stop shiny-server\nsudo systemctl start shiny-server\n\n# Revisar status del servicio\nsudo systemctl status shiny-server\n\nSi el servicio está activo, podemos probar con la IP externa, la puerta 3838 e indicamos el nombre de la aplicación. Debería de ser algo similar a: ip:3838/shiny_modular/\n¡Y listo! Con esto tenemos los pasos básicos para desplegar nuestra aplicación de shiny en nuestro servidor y hacerla disponible al mundo.\nReferencias\nEl resumen de pasos mostrados en esta guía han sido tomados y adaptados de diversas fuentes como:\nDigitalOcean (Algún día lograré documentar como lo hacen ellos)\nShiny Server Professional v1.5.15 Administrator’s Guide El sitio a visitar cuando hay problemas con shiny-server. Es documentación técnica\n\n\n\n",
    "preview": "posts/2021-12-11-desplegando-shiny/images/app.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-tiempo-en-r/",
    "title": "Tiempo en R",
    "description": "Trabajar con fechas y tiempo en R es un poco complicado. En este post trato de explicar cómo trabajar con este tipo de datos y base R",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2018-03-14",
    "categories": [],
    "contents": "\nTiempo\nLa medición del tiempo es algo que puede ser particular, ya que hay meses con diferente número de días, en distintos países la manera de colocar el dato del día o del mes se cambia, en años bisiestos febrero tiene un día extra entre otros factores, hay diferentes\nPor ende, hacer cálculos con fechas puede resultar algo complicado, sin embargo R tiene un sistema robusto para poder lidiar con estas situaciones.\nFechas y Horas en R:\nR tiene diversas maneras de representar objetos en el sistema. Más allá de los dobles, enteros, carácteres, lógicos y complejos, R tiene una clase especial para representar las fechas y horas.\nSi queremos revisar cuál es la fecha y hora que tenemos en nuestro sistema podemos hacerlo con la función Sys.time()\n\n\nSys.time()\n\n\n[1] \"2021-12-11 14:50:07 MST\"\n\nLo que nos muestra es una descripción de la fecha y hora de manera meramente jerárquica: la escala más grande (años) va primero, seguido por el mes y por último el día, separados entre sí por un guión; luego hay un espacio en blanco y bajo la misma lógica tenemos la hora, los minutos y los seugundos, separados cada uno por dos punto. Al final tenemos un dato que nos indica el sistema de tiempo utilizado, en este caso Central Standard Time.\nEsta convención es buena para poder leer de manera fácil, sin embargo, para la realización de cálculos esto es un poco difícil por lo que el manejo de estas a lo “interno” de R se hace basado en segundos.\nTipo y Clase del tiempo en R:\nPara revisar su tipo de dato y su clase vamos a guardar esta fecha y hora de nuestro ordenador en un objeto de la siguiente manera:\n\n\nfecha_hora <- Sys.time() # Guardar en un objeto\n\ntypeof(fecha_hora) # Tipo de dato\n\n\n[1] \"double\"\n\nclass(fecha_hora) # Clase del objeto\n\n\n[1] \"POSIXct\" \"POSIXt\" \n\nAl momento de utilizar la funciónSys.time(), nos devuelve una respuesta que a primera instancia nos parecería un objeto de tipo character por sus comillas alrededor de esto, sin embargo, al revisar podemos notar que es un objeto de tipo double y su clase es _ “POSIXct” “POSIXt” _ (tiene dos clases)\n¿Qué signifan esas dos clases?\nComo mencionamos anteriormente, por convención en R se utiliza una representación numérica, basada en segundos. Esto quiere decir que cada fecha se representa por el número de segundos que han transcurrido desde las 12:00 A.M. del 1 Enero de 1970.  (UTC: Coordinated Universal Time)\nEsto es bastante útil si queremos generar gráficos de series de tiempo, pero qué sucede si queremos representar las medias por mes, o por día. En este caso es necesario contar con dos maneras de representar las fechas:\nPOSIXct el sufijo ct se refiere a continuos time y este formato es representado de manera númerica por segundos. Este es un vector que se puede usar como una variable continua en modelos de regresión.\nPOSIXlt el sufijo lt corresponde a list time y lo que hace es una lista de todas las descripciones categóricas del tiempo. Es muy útil como variable explicativa categórica.\n¿Cómo funcionan el sistema POSIX?\nPara revisar de qué manera R hace esto podemos hacer uso de la función unclass()\n\n\nunclass(fecha_hora)\n\n\n[1] 1639259408\n\nEl resultado que obtenemos es un elemento que R utiliza para construir un vector doble. Lo que tenemos allí es que desde las 12:00 A.M. del 1 de Enero de 1970 han transcurrido 1 514 244 708 hasta el día en que este tutorial se ha creado y este es el formato POSIXct\nEn el caso de caso de una lista como POSIXlt vamos a revisar los componentes del mismo objeto con el que hemos venido trabajando:\n\n\nfecha_hora <- as.POSIXlt(fecha_hora) # Definimos formato\nunlist(fecha_hora) # Sacamos de la lista los objetos almacenados\n\n\n               sec                min               hour \n\"7.87694835662842\"               \"50\"               \"14\" \n              mday                mon               year \n              \"11\"               \"11\"              \"121\" \n              wday               yday              isdst \n               \"6\"              \"344\"                \"0\" \n              zone             gmtoff \n             \"MST\"           \"-25200\" \n\n¿Qué es lo que tenemos? Se nos muestran los componentes de la lista, que está representada por el número de segundos, minutos, hora (en formato de 24 horas). Luego viene mday que es el día del mes (inicia en 1), mon es el mes del año (comienza en enero = 0), year que representa el año (inicia en 0 = 1900),wday el día de la semana (inicia domingo = 0), yday es el número de día del año (1 de enero = 0). Por último la variable isdst lo que hace es indicarnos si un horario de verano está siendo considerado (0 = FALSE, como en este caso)\nLeer fechas desde archivos\nCuando traemos datos a R, en ocasiones hay que hacerle explícito a R el tipo de datos que tenemos. En el caso de las fechas es necesario, ya que de esta forma determinamos qué dato corresponde a cuál componente de lo que se considera una fecha u hora.\nVamos a utilizar el set de datos Flights that Depart NYC in 2013 que tiene como nombre nycflights13. Este se encuentra en el paquete con el mismo nombre. (Si no lo tienen, pueden instalarlo con la función install.packages(\"nycflights13\"))\n\n\ndata <- nycflights13::flights # Guardar en objeto datos seleccionados\nhead(data)\n\n\n# A tibble: 6 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time\n  <int> <int> <int>    <int>          <int>     <dbl>    <int>\n1  2013     1     1      517            515         2      830\n2  2013     1     1      533            529         4      850\n3  2013     1     1      542            540         2      923\n4  2013     1     1      544            545        -1     1004\n5  2013     1     1      554            600        -6      812\n6  2013     1     1      554            558        -4      740\n# … with 12 more variables: sched_arr_time <int>, arr_delay <dbl>,\n#   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>,\n#   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n\nEl conjunto de datos trae 3 columnas con el año, el mes y el día, los cuales vamos a unir y darle format de fecha:\n\n\nlibrary(tidyr) # Paquete del cual vamos a utilizar función\ndata <- unite(data, Date, year, month,day, sep = \"/\")\nhead(data)\n\n\n# A tibble: 6 × 17\n  Date     dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  <chr>       <int>          <int>     <dbl>    <int>          <int>\n1 2013/1/1      517            515         2      830            819\n2 2013/1/1      533            529         4      850            830\n3 2013/1/1      542            540         2      923            850\n4 2013/1/1      544            545        -1     1004           1022\n5 2013/1/1      554            600        -6      812            837\n6 2013/1/1      554            558        -4      740            728\n# … with 11 more variables: arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>\n\nFunción strptime\nYa que tenemos dicha column creada, vamos a indicarle R qué de esos datos pertenece al año, al mes y al día:\n\n\nRdate <- strptime(as.character(data$Date), \"%Y/%m/%d\")\nclass(Rdate)\n\n\n[1] \"POSIXlt\" \"POSIXt\" \n\nYa tenemos el objeto creado con las fechas por lo que ahora podemos unirlo al set de datos:\n\n\ndata <- data.frame(Rdate,data)\nhead(data)\n\n\n       Rdate     Date dep_time sched_dep_time dep_delay arr_time\n1 2013-01-01 2013/1/1      517            515         2      830\n2 2013-01-01 2013/1/1      533            529         4      850\n3 2013-01-01 2013/1/1      542            540         2      923\n4 2013-01-01 2013/1/1      544            545        -1     1004\n5 2013-01-01 2013/1/1      554            600        -6      812\n6 2013-01-01 2013/1/1      554            558        -4      740\n  sched_arr_time arr_delay carrier flight tailnum origin dest\n1            819        11      UA   1545  N14228    EWR  IAH\n2            830        20      UA   1714  N24211    LGA  IAH\n3            850        33      AA   1141  N619AA    JFK  MIA\n4           1022       -18      B6    725  N804JB    JFK  BQN\n5            837       -25      DL    461  N668DN    LGA  ATL\n6            728        12      UA   1696  N39463    EWR  ORD\n  air_time distance hour minute           time_hour\n1      227     1400    5     15 2013-01-01 05:00:00\n2      227     1416    5     29 2013-01-01 05:00:00\n3      160     1089    5     40 2013-01-01 05:00:00\n4      183     1576    5     45 2013-01-01 05:00:00\n5      116      762    6      0 2013-01-01 06:00:00\n6      150      719    5     58 2013-01-01 05:00:00\n\n¿Qué fué lo que hicimos?\nLa columna date contenía datos separados por un guión, en donde el primer dato pertenecía al año, el segundo al mes y el tercero al día, por ende le dijimos a R que leyera esos datos como año, mes y día separados por un /: (\"%Y/%m/%d\")\nEstas son abreviaciones que dan a entender diferentes formas de leer el dato en R. La siguiente es una lista de todas las abreviaciones:\nSímbolo\nSignificado\n%a\nNombre de la semana abreviado\n%A\nNombre de la semana completo\n%b\nNombre del mes abreviado\n%B\nNombre del mes completo\n%c\nHora y Fecha específica a la localidad\n%d\nDía del mes como un número decimal (01-31)\n%H\nHoras como decimales en reloj de 24 horas\n%I\nHoras como decimales en reloj de 12 horas\n%j\nDía del año como número decimal (0 - 366)\n%m\nMes como un número decimal (0-11)\n%M\nMinutos como un número decimal (00 - 59)\n%p\nAM/PM indicador en la localidad\n%S\nSegundos como número decimal (00 - 61)\n%U\nSemana del año (00 - 53) usando el primer domingo como el día 1 de la semana 1\n%w\nDía de la semana como un número decimal (0 - 6, Domingo es 0)\n%W\nSemana del año (00 - 53) usando el primer lunes como día 1 de la semana 1\n%x\nFecha, específica de la localidad\n%X\nHora, específica de la localidad\n%Y\nAño con centenario\n%y\nAño sin centenario\n%Z\nZona horaria como un vector de tipo caracter\nNombre completo del día:\nAhora bien, hay ocasiones en que por ejemplo, tenemos el día como un número, pero nos serviría más tener el nombre del día. Para esto existe la función weekdays()\n\n\nejemplo <- data[1,1]\nejemplo\n\n\n[1] \"2013-01-01 MST\"\n\nTenemos el 1ero de enero del 2013, ahora queremos ver qué día es este con su nombre:\n\n\nweekdays(ejemplo)\n\n\n[1] \"Tuesday\"\n\nOtros formatos\nFechas pueden venir en diversas formas, tenemos que aprender cómo lidiar con estas y cómo hacerle explícito a R qué es qué. Para esto tenemos como ayuda la tabla presentada anteriormente.\nUn ejemplo podría ser el siguiente:\n\n\notras_fechas <- c(\"2feb2016\",\"18jun1990\",\"7nov1995\")\nstrptime(otras_fechas,\"%d%b%Y\")\n\n\n[1] \"2016-02-02 MST\" \"1990-06-18 MDT\" \"1995-11-07 MST\"\n\n¿Qué hicimos?\nLeímos un conjunto de fechas que tenían un formato de día, seguido del nombre del mes y por último el año completo y se lo hicimos saber a R indicándole %día, luego %mes y por último %año.\nAhora cada vez que tengamos fechas, sabremos que debemos indicarle a R qué contienen esos datos y qué es qué guiándonos con la tabla provista.\nCálculos con el tiempo:\nPara tener la diferencia entre dos fechas, podemos echar mano de la función difftime(). Hay que tomar en cuenta que esta función nos devuelve un objeto de clase difftime\nDiferencias entre fechas en un vector\n\n\n# Primero hacemos un objeto a clase difftime:\nas.difftime(otras_fechas, \"%d%b%Y\")\n\n\nTime differences in days\n[1]  -2139 -11499  -9531\n\nCálculos con dos objetos:\nHay cálculos que se pueden generar con fechas y horas, ya sea sumando a una fecha o a una hora un número (que representará segundos), también entre fechas/horas e inclusive la utilización de operadores lógicos.\n\n\n# vamos a generar dos fechas:\n\nfecha_1 <- as.POSIXlt(\"2018-01-01\")\nfecha_2 <- as.POSIXlt(\"2017-01-02\")\n\n\n\nY podemos sumar una fecha con un número:\n\n\nfecha_1 + 100000\n\n\n[1] \"2018-01-02 03:46:40 MST\"\n\nEsto nos suma cien mil segundos, lo cual agrega 3 horas, 46 minutos y 40 segundos a la fecha que habíamos creado.\nPodemos resta esa misma cantidad de segundos:\n\n\nfecha_1 - 100000\n\n\n[1] \"2017-12-30 20:13:20 MST\"\n\nVemos que nos devuelve al 30 de diciembre del 2017 a las 20 con 13 minutos y 20 segundos.\nRestarle a la fecha 1 la fecha 2:\n\n\nfecha_1 - fecha_2\n\n\nTime difference of 364 days\n\nNos dice que entre las fechas hay 364 días.\nHacer una operación lógica:\n\n\nfecha_1 <= fecha_2\n\n\n[1] FALSE\n\nSi decimos que fecha_1 es menor o igual que fecha_2 R nos dice que eso es falso.\nDiferencia de días:\nSi tenemos una pregunta como: ¿Cuántos días han transcurrido desde el 1 de diciembre del 2017 al 2 de enero del 2018?\n\n\ndifftime(\"2018-01-02\",\"2017-12-01\")\n\n\nTime difference of 32 days\n\nLa respuesta es que han transcurrido 32 días.\nDiferencia de horas:\nEn este caso, si tenemos horas en lugar de fechas, podemos hacer uso de la función as.difftime()\n\n\ntiempo_1 <- as.difftime(\"12:00:00\")\ntiempo_2 <- as.difftime(\"17:20:00\")\ntiempo_2 - tiempo_1\n\n\nTime difference of 5.333333 hours\n\nNos dice cuál es la diferencia en horas. (Si te preguntas porqué 5.33 en lugar de 5 horas y 20 minutos, recuerde que la respuesta está dada en horas y 20 minutos corresponden a 0.333 horas)\nGeneración de secuencias con tiempo:\nSi queremos generar secuencias de fechas, años, meses, semanas etc, en R lo podemos realizar sin mucho problema:\nSecuencia en aumento por día:\n\n\nseq(as.POSIXlt(\"2018-01-01\"), as.POSIXlt(\"2018-01-10\"), \"1 day\")\n\n\n [1] \"2018-01-01 MST\" \"2018-01-02 MST\" \"2018-01-03 MST\"\n [4] \"2018-01-04 MST\" \"2018-01-05 MST\" \"2018-01-06 MST\"\n [7] \"2018-01-07 MST\" \"2018-01-08 MST\" \"2018-01-09 MST\"\n[10] \"2018-01-10 MST\"\n\n¿Qué hicimos? La función seq() nos genera un vector con una serie de valores de una secuencia, en este caso le indicamos dos elementos de tipo POSIXlt que corresponden a fechas y un último argumento que indica 1 día. Es decir, que del 1ero de enero del 2018 al 10 de enero del 2018 queremos una secuencia entre esas fechas que aumente de 1 día en 1 día.\nSecuencia en aumento por semanas:\n\n\nseq(as.POSIXlt(\"2018-01-01\"), as.POSIXlt(\"2018-02-01\"), \"1 weeks\")\n\n\n[1] \"2018-01-01 MST\" \"2018-01-08 MST\" \"2018-01-15 MST\"\n[4] \"2018-01-22 MST\" \"2018-01-29 MST\"\n\n¿Qué hicimos? Nuevamente indicamos un par de fechas que delimitan el inicio y el final de la secuencia y por último le decimos que la secuencia aumente de semana en semana.\nEsto lo podemos hacer de igual manera si queremos que la secuencia aumente por meses months o por años year\nSecuencia en aumento por tiempo en segundos:\n\n\nseq(as.POSIXlt(\"2018-01-01\"),as.POSIXlt(\"2018-01-02\"),8000)\n\n\n [1] \"2018-01-01 00:00:00 MST\" \"2018-01-01 02:13:20 MST\"\n [3] \"2018-01-01 04:26:40 MST\" \"2018-01-01 06:40:00 MST\"\n [5] \"2018-01-01 08:53:20 MST\" \"2018-01-01 11:06:40 MST\"\n [7] \"2018-01-01 13:20:00 MST\" \"2018-01-01 15:33:20 MST\"\n [9] \"2018-01-01 17:46:40 MST\" \"2018-01-01 20:00:00 MST\"\n[11] \"2018-01-01 22:13:20 MST\"\n\nEn este caso 8000 segundos nos genera un aumento de 2 horas, 13 minutos y 20 segundos en cada elemento de la secuencia.\nSecuencia sin especificación de final:\n\n\nseq(as.POSIXlt(\"2018-01-01\"), by = \"weeks\", length = 7)\n\n\n[1] \"2018-01-01 MST\" \"2018-01-08 MST\" \"2018-01-15 MST\"\n[4] \"2018-01-22 MST\" \"2018-01-29 MST\" \"2018-02-05 MST\"\n[7] \"2018-02-12 MST\"\n\n¿Qué hicimos? Generamos nuevamente una secuencia en donde sólo le indicamos la fecha en la que debe de iniciar, seguido del argumento semanas y por último la cantidad de objetos que debería de crear. Es decir, el final está generado por la cantidad (length) de elementos que queremos en esa secuencia.\nRecuento.\n¡Listo! Si has llegado hasta este punto, felicidades. Espero que haya comprendido mejor cómo trabajar y manejar este tipo de dato para sus propios análisis.\nHasta acá hemos visto cuáles son los tipos y la clase de las fechas y horas en R, la diferencia entre las dos manera de POSIX de representar las fechas u horas. También revisamos la manera en que se pueden leer archivos o conjuntos de datos que contengan elementos que corresponden a fechas y cómo indicarle a R el formato de fecha y hora que se está trabajando. Así mismo vimos cómo hacer algunos cálculos con datos de tiempo y por último la generación de secuencias.\nPero esto no es todo. Hay una segunda parte, en donde veremos cómo hacer un análisis de datos utilizando fechas y horas, tal como una regresión o un ANOVA.\n\n\n\n",
    "preview": "posts/2021-12-11-tiempo-en-r/images/time.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-estructuras-r/",
    "title": "Intro a datos y estructuras en R",
    "description": "Una breve intro a estructuras en R.",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2018-02-01",
    "categories": [],
    "contents": "\nDatos y Estructuras\nEste pequeño e introductorio tutorial consiste en explicar cómo R en su entorno “entiende” los datos (objetos), es decir sus clases y además cómo los almacena en ese entorno. Entender este tipo de cosas básicas en R nos podrán ahorrar dolores de cabeza en futuros análisis de datos que hagamos.\nPrimer paso:\nPrimero tenemos que entender que R lee los datos que le damos de distintas maneras para poder manejarlos y hacer tareas que le pidamos. Entre estos tenemos:\ncharacter: corresponden a texto\nnumeric: corresponden a números\ninteger: son números enteros (sin decimales)\nlogical: son condicionales y están en forma de verdadero o falso\ncomplex: corresponden a números complejos\nPara crear vectores c( )\n\n\na <- c(\"biologia\", \"A\", \"estadistica\")\nclass(a)\n\n\n[1] \"character\"\n\n\n\nb <- c(18.6, 90)\nclass(b)\n\n\n[1] \"numeric\"\n\n\n\nc <- c(18L, 26L)\nclass(c)\n\n\n[1] \"integer\"\n\n\n\nd <- 2 + 4i\nclass(d)\n\n\n[1] \"complex\"\n\n\n\ne <- c(TRUE, FALSE)\nclass(e)\n\n\n[1] \"logical\"\n\n¿Para qué sirven los tipos de datos?\nHay ciertas cosas que se deben de tomar en cuenta a la hora de trabajar con datos en R, y es que estos son guardados en estructuras. Es decir, R “acomoda” esos datos en formas que los puede manejar.\nEstos son algunos ejemplos rápidos:\nVectores elementos son del mismo tipo\n\n\nv_1 <- c(10,20,30)\nv_2 <- c(\"a\",\"b\",\"c\")\nv_3 <- c(TRUE,FALSE,TRUE)\n\n\n\nListas elementos son de diferente tipo\n\n\nl_1 <- list(v_1,v_2,v_3)\n\nl_1\n\n\n[[1]]\n[1] 10 20 30\n\n[[2]]\n[1] \"a\" \"b\" \"c\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE\n\nmatrix es de dos dimensiones con elementos del mismo tipo:\n\n\nmatrix_1 <- matrix(1:9,nrow = 3, ncol = 3)\nmatrix_1\n\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\ndata frame es de dos dimensiones con elementos de diferente tipo:\n\n\n# Primero creamos un par de vectores para unirlos en un dataframe\nnumero <- 1:5\nnombre <- c(\"Mercurio\",\"Venus\",\"Tierra\",\"Marte\",\"Jupiter\")\nplaneta <- data.frame(numero,nombre)\nplaneta\n\n\n  numero   nombre\n1      1 Mercurio\n2      2    Venus\n3      3   Tierra\n4      4    Marte\n5      5  Jupiter\n\nArray es una estructura de tres o más dimensiones:\n\n\nD <- 1:12\ndim(D) <- c(2,3,2)        # Dos filas, tres columnas y dos \"caras\"\nD\n\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\nManeras de coercionar las clases\nHay ocasiones en las cuales R podría confundir lo que nosotros consideramos un dato de cierto tipo, por ejemplo un número lo podría leer como un carácter. A la hora de hacer algunos cálculos habrán problemas.\nPero existe una solución y esto es coercionar los tipos de los datos. Esto se puede hacer tal como se muestra en los siguientes ejemplos:\n\n\nbiolo_vector <- c(20, 40, \"A\", 80)\nclass(biolo_vector)\n\n\n[1] \"character\"\n\nz <- as.numeric(biolo_vector)\nz\n\n\n[1] 20 40 NA 80\n\n\n\nbiolo_vector <- c(20, 40, TRUE, 80)\nclass(biolo_vector)\n\n\n[1] \"numeric\"\n\nbiolo_vector\n\n\n[1] 20 40  1 80\n\n\n\nbiolo_vector <- c(20:60)\nbv_1 <- as.character(biolo_vector)\nbv_2 <- as.logical(biolo_vector)\nbv_3 <- as.complex(biolo_vector)\nclass(bv_1)\n\n\n[1] \"character\"\n\nclass(bv_2)\n\n\n[1] \"logical\"\n\nclass(bv_3)\n\n\n[1] \"complex\"\n\nExploración datos:\nCuando traemos datos a R hay una manera fácil de visualizar su estructura o forma sin tener que acudir al documento original. A continuación mostramos una serie de ejemplos en los cuales se m\n\n\ndir()                              # ver que tengo en el wd\nhead(data)                         # Ver primeros 6 observaciones\ntail(data)                         # últimas 6 observaciones\nstr(data)                          # estructura del data.frame\ndim(data)                          # dimensiones (rows & columns)\nnames(data)                        # nombres columnas\nglimpse(data)                      # paquete diplyr\nsummary(data)                      # resumen de cada variable\n\n\n\n¿Qué siginifica dir() y ls()?\ndir () me refiere a los archivos que se encuentran en el directorio de trabajo. ls () me refiere a los objetos que se encuentran en el espacio de trabajo\nComprensión de un data frame y su estructura\nPara comprender mejor vamos a construir un data.frame de manera rápida y simple:\nCreamos los vectores a unir:\n\n\nprimer_nombre <- c(\"Isaac\",\"Charles\",\"Rosalind\",\"Marie\") \n\nsegundo_nombre <- c(\"Newton\",\"Darwin\",\"Franklin\",\"Curie\")\n\nedad_muerte <- c(84, 73, 37, 66)\n\ncampo <- c(\"Física\", \"Biología\", \"Química\", \"Física\")\n\nfecha_muerte <- as.Date(c(\"1643-1-4\", \"1882-4-19\",\n                        \"1958-4-16\", \"1934-7-4\"))\n\n\n\nUnimos cada uno de los vectores en un data.frame\n\n\ncientificos <- data.frame(primer_nombre, segundo_nombre,\n                          edad_muerte, campo, fecha_muerte)\n\n\n\nRevisemos estructura igual que en caso anterior\n\n\nhead(cientificos)\n\n\n  primer_nombre segundo_nombre edad_muerte    campo fecha_muerte\n1         Isaac         Newton          84   Física   1643-01-04\n2       Charles         Darwin          73 Biología   1882-04-19\n3      Rosalind       Franklin          37  Química   1958-04-16\n4         Marie          Curie          66   Física   1934-07-04\n\nstr(cientificos)\n\n\n'data.frame':   4 obs. of  5 variables:\n $ primer_nombre : chr  \"Isaac\" \"Charles\" \"Rosalind\" \"Marie\"\n $ segundo_nombre: chr  \"Newton\" \"Darwin\" \"Franklin\" \"Curie\"\n $ edad_muerte   : num  84 73 37 66\n $ campo         : chr  \"Física\" \"Biología\" \"Química\" \"Física\"\n $ fecha_muerte  : Date, format: \"1643-01-04\" ...\n\n#glimpse(cientificos) con librería dplyr\n\n\n\n\n\n\n",
    "preview": "posts/2021-12-11-estructuras-r/images/structure.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-datos-abiertos-muni-sanjose/",
    "title": "Datos abiertos municipalidad de San José, Costa Rica",
    "description": "Una introducción al uso del API de datos abiertos de la muni de San José",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      },
      {
        "name": "Erick Calderón Morales",
        "url": "https://github.com/ecamo19"
      }
    ],
    "date": "2018-01-13",
    "categories": [],
    "contents": "\nGracias a la iniciativa de Gobierno Abierto de Costa Rica tenemos la posibilidad de obtener datos de diferentes entes a través de la conexión con API’s.\nEsto nos da la posibilidad de no pasar por engorrosos procesos de limpiar datos a partir de formatos casi imposibles como pdf’s, .csv extravagantes u otros formatos difíciles de trabajar.\nEn este caso vamos a utilizar el lenguaje de programación R y el paquete junr de Frans van Dunné para conectarnos al API de la municipalidad de San José y revisar qué datos se encuentran disponibles.\nObtener el API key de la municipalidad de San José\nEn la siguiente dirección podrá encontrar el API key necesario para hacer el llamado.\nVamos a crear como objetos nuestras credenciales para hacer la conexión al API de la municipalidad de San José. El url que aparece acá es el que se debe de usar para conectarnos al sistema de la muni de San José. Si están siguiendo ete ejemplo pueden escribir el mismo que aparece acá.\n\n\nurl_base <- \"http://api.datosabiertos.msj.go.cr/api/v2/datastreams/\"\napi_key <- SU_API_KEY\n\n\n\nObtener el indice de las tablas\nYa que tenemos las credenciales listas (api key & url), vamos a revisar el índice de las tablas de datos que la municipalidad ha liberado:\n\n\n# Traemos el indice  de los datos que existen\nindice <- get_index(url_base, api_key = api_key)\n\n# Revisamos estructura del objeto \nglimpse(indice)\n\n## Observations: 257\n## Variables: 18\n## $ status          <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n## $ description     <chr> \"Valor absoluto y Tasa por 100.000 2006 - 2014\",…\n## $ parameters      <list> [[], [], [], [], [], [], [], [], [], [], [], []…\n## $ tags            <list> [<\"san jose\", \"municipalidad\", \"muertes violent…\n## $ timestamp       <dbl> 1.547586e+12, 1.539808e+12, 1.516222e+12, 1.5162…\n## $ created_at      <int> 1547586293, 1539744226, 1516221668, 1516220839, …\n## $ title           <chr> \"Cantidad y Tasa de muertes violentas\", \"Densida…\n## $ modified_at     <int> 1547586492, 1539808089, 1516221733, 1516221641, …\n## $ category_id     <chr> \"83642\", \"83639\", \"83481\", \"83481\", \"83482\", \"83…\n## $ methods         <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n## $ sources         <list> [<>, <\"Municipalidad de San José\", \"Instituto N…\n## $ total_revisions <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n## $ frequency       <chr> \"\", \"ondemand\", \"\", \"\", \"\", \"ondemand\", \"ondeman…\n## $ link            <chr> \"http://datosabiertos.msj.go.cr/dataviews/250481…\n## $ user            <chr> \"sanjose\", \"sanjose\", \"sanjose\", \"sanjose\", \"Msj…\n## $ status_str      <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n## $ guid            <chr> \"CANTI-Y-TASA-DE-92062\", \"DENSI-DE-POBLA-POR-DIS…\n## $ category_name   <chr> \"Características Sociales\", \"Demografía\", \"Educa…\n\n\n\nCada uno de los elementos que allí aparecen son distintas tablas que pueden tener diferentes dimensiones (filas y columnas). Es como una descripción de lo que trata cada tabla. Si queremos traer a nuestro entorno los datos de una tabla en específico tenemos que hacerlo con su GUID.\nDe toda la tabla que llamamos en el paso anterior, vamos a hacer una selección de dos columnas: título y el GUID\n\n\nguid <- indice %>% \n  select(title, guid)\n\nglimpse(guid)\n\n## Observations: 257\n## Variables: 2\n## $ title <chr> \"Cantidad y Tasa de muertes violentas\", \"Densidad de Pobla…\n## $ guid  <chr> \"CANTI-Y-TASA-DE-92062\", \"DENSI-DE-POBLA-POR-DISTR\", \"DIST…\n\n\n\nObtener las dimensiones de las tablas\nAhora bien, ya sabemos el título y el identificador de la tabla, pero tenemos que tener cuidado. Son muchas tablas y algunas pueden estar vacías, ser datos resumidos o con muy pocos datos que no nos servirían de nada.\nPor suerte el paquete junr tiene una función que nos muestra la dimensión de las tablas, lo cual nos da mayor información sobre las características que tiene.\nHay que aclarar que la municipalidad de San José tiene muchas tablas y si usamos la función para obtener las dimensiones se puede demorar sus minutos.\n\n\n# Por la cantidad de tablas que hay, esta funcion se demora mucho\ndimensiones <- get_dimensions(base_url = url_base, api_key = api_key)\n\n# Mostrar primeras seis observaciones\nhead(dimensiones)\n\n##                          GUID NROW NCOL DIM\n## 2       CANTI-Y-TASA-DE-92062    6   10  60\n## 21   DENSI-DE-POBLA-POR-DISTR   15   12 180\n## 3  DISTR-RELAT-DE-ESTUD-MATRI   12   10 120\n## 4  DISTR-DE-ESTUD-MATRI-77173   12   10 120\n## 5        POA-PRESU-ORDIN-2018  119    3 357\n## 6     INVER-EN-COLON-EN-43060    7    6  42\n\n\n\nCuadro con características de las tablas de la muni de SJ\nYa que tenemos las dimensiones de las tablas, podemos acomodar la información que hemos extraido hasta el momento de tal manera que tengamos un cuadro final con la información importante resumida: el título de la tabla, el GUID y las dimensiones.\n\n\n# Unir el titulo a dimensiones\ndimensiones <- left_join(dimensiones, guid, by = c(\"GUID\" = \"guid\"))\n\n# Ordenar tablas con mayores dimensiones\ndim_ordenado <- dimensiones %>%\n  arrange(desc(DIM))\n\n# Revisar primeras entradas\nhead(dim_ordenado)\n\n##                         GUID NROW NCOL DIM\n## 1          ASIST-EDUCA-SUPER  108    9 972\n## 2                DEFUN-28990   64   13 832\n## 3                DEFUN-43464   64   13 832\n## 4                NACIM-43692   64   13 832\n## 5 DISTR-DE-POBLA-OCUPA-56023   52   11 572\n## 6 DISTR-DE-POBLA-OCUPA-36314   52   11 572\n##                                                                title\n## 1                                      Asistencia Educación Superior\n## 2                                                        Defunciones\n## 3                                                        Defunciones\n## 4                                                        Nacimientos\n## 5 Distribución de población ocupada por Grupo Ocupacional (Relativo)\n## 6            Distribución de población ocupada por Grupo Ocupacional\n\n\n\nLlamar datos de una tabla específica:\nYa con esto podemos hacer una mejor selección de las tablas que nos serían útiles. Cuando ya tengamos identificada una tabla tenemos que anotar su GUID que utilizaremos en la función:\n\n\n# Anotar en un objeto el GUID de la tabla que nos interesa\nguid_tabla <- \"ASIST-EDUCA-SUPER\"\n\n# Llamar la tabla. Usamos las mismas credenciales que habíamos usado\nasist_educacion <- get_data(base_url = url_base, api_key = SU_API_KEY, \n                            guid = guid_tabla)\n\n\n\n¡Listo! Ya tenemos nuestra tabla de interés con los datos. Vamos a revisarla\n\n\nhead(asist_educacion)\n\n##   Distrito   Sexo Tenencia de título Parauniversitaria Universitaria Total\n## 2 San José Hombre                 Sí              1951         24058 26009\n## 3 San José Hombre                 No               653          3498  4151\n## 4 San José Hombre              Total              2604         27556 30160\n## 5 San José  Mujer                 Sí              2599         26085 28684\n## 6 San José  Mujer                 No               924          4092  5016\n## 7 San José  Mujer              Total              3523         30177 33700\n##   Población de 17 años y más\n## 2                           \n## 3                           \n## 4                     100238\n## 5                           \n## 6                           \n## 7                     116461\n##   Porcentaje de población con educación superior\n## 2                                               \n## 3                                               \n## 4                                           30.1\n## 5                                               \n## 6                                               \n## 7                                           28.9\n##   Porcentaje de población con educación superior y título\n## 2                                                        \n## 3                                                        \n## 4                                                    86.2\n## 5                                                        \n## 6                                                        \n## 7                                                    85.1\n\nglimpse(asist_educacion)\n\n## Observations: 108\n## Variables: 9\n## $ Distrito                                                  <fct> San Jo…\n## $ Sexo                                                      <fct> Hombre…\n## $ `Tenencia de título`                                      <fct> Sí, No…\n## $ Parauniversitaria                                         <fct> 1951, …\n## $ Universitaria                                             <fct> 24058,…\n## $ Total                                                     <fct> 26009,…\n## $ `Población de 17 años y más`                              <fct> , , 10…\n## $ `Porcentaje de población con educación superior`          <fct> , , 30…\n## $ `Porcentaje de población con educación superior y título` <fct> , , 86…\n\n\n\nReferencias\nvignette del paquete junr\nPágina desarrolladores Municipalidad de San José\nGobierno abierto Costa Rica\n¿Querés revisar más información?\nMi compañero Erick Calderón y yo estamos trabajando en un proyecto donde pretendemos crear más tutoriales sobre uso de datos abiertos del gobierno de Costa Rica a través de API’s y el lenguaje de programación R. Si querés contribuir, tenés preguntas o una idea podés revisar nuestro proyecto en Github\n\n\n\n",
    "preview": "posts/2021-12-11-datos-abiertos-muni-sanjose/images/city.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-12-11-otra-intro-a-git/",
    "title": "Otra introducción a git",
    "description": "Una introducción al control de versiones con git (otra más).",
    "author": [
      {
        "name": "Ronny A. Hernández Mora",
        "url": "http://ronnyhdez.rbind.io/"
      }
    ],
    "date": "2016-04-20",
    "categories": [],
    "contents": "\n¿Qué resuelve git? ¿Porqué usar git?\nSi les ha sucecido que luego de trabajar en un documento, tienen una carpeta llena con nombres como: “version_final”, “version_final_final”, “version_final_corregida”, “version_final_revisada” pues git les será útil para tener un control sobre los cambios que se introducen en el documento.\nEn este tutorial haremos ejemplos con scripts de código en R y cómo los cambios que vayamos trabajando, los podemos registrar, usar, guardar y documentar con mayor eficiencia tanto para trabajar individualemente como grupalmente.\nEsquema de git\nAqui pretendo aclarar rapidamente que vamos a hacer con git, tener el bosquejo antes de entrar en detalles. Vamos a tener un repositorio remoto o en inglés upstream que será nuestro repositorio en github/gitlab/bitbucket. De este repositorio tendremos uno local que crearemos al hacer el clon. Siempre vamos a trabajar en repositorio local (en nuestra computadora) y esos cambios los vamos a subir al remoto con un push. De igual manera cambios que existan en el repositorio remoto (porque alguien hizo una contribucion, trabajamos desde otra computadora ys ubimos los cambios) lo vamos a hacer con un pull.\nVamos a tener una rama principal llamada master. El consejo aca es tener código limpio y funcional. Todo lo que sea trabajo en desarrollo, experimentos, pruebas o tareas específicas, vamos a hacerlo en ramas. Las ramas van a tener el nombre que nosotros decidamos. Los cambios que se encuentran en estas ramas, una vez que se encuentran finalizados, revisados y funcionales los podremos integrar a nuestra rama master en un proceso conocido como merge\nCada vez que hagamos cambios en el código, vamos a hacer un commit. Esto lo podemos interpretar como marcar un punto en la historia del proyecto. Git nos mostrará información sobre cada uno de nuestros commits tal como la fecha, hora, usuario, archivos cambiados y las líneas de los archivos que se cambiaron. La idea de los commits es que siempre podamos retornar a un punto específico en la historia del proyecto.\nEn el caso de trabajar con el repositorio de alguien más, lo podemos realizar a través de un proceso que se conoce como fork, que no es más que una bifurcación del repositorio de esa persona. Al realizar un “fork” del repositorio de otra persona estamos creando una copia de dicho repositorio bajo nuestro usuario. Ahora bien, la manera de ofrecer los cambios que hemos trabajado a la persona dueña del repositorio tiene un proceso algo diferente que veremos en otro tutorial.\nIniciar con git\nEn este segmento vamos a seguir los pasos para tener un repositorio que tenga su cuenta remota con github/gitlab/bitbucket y local a través de nuestra terminal.\n1. Crear repositorio en github/gitlab/bitbucket\nSi tenemos cuenta en github/gitlab/bitbucket podemos crear un repositorio. Le llamamos repositorio al sitio donde vamos a guardar nuestros archivos. Un repositorio lo podemos visualizar como una carpeta que contendrá nuestro trabajo.\nCuando se crea un nuevo repositorio lo recomendable es iniciarlo con un arhivo que se llama .gitignore y con un readme. Para hacerlo en github (y algo similar en otras plataformas) es que seleccionemos las opciones de iniciar repositorio con un archivo .gitignore y un readme. El archivo gitignore debe de ser específico para la herramienta que vayamos a usar, en este caso sería R\nLa funcionalidad del .gitignore es que este archivo (es como un archvio de texto) contiene especificaciones sobre los formatos de los archivos que no queremos que se integren en nuestro sistema de control de versiones. Generalmente no deseamos que archivos como imagenes (.png .jpeg) o bien archivos de datos muy grandes (.txt .csv .feather) sean compartidos entre repositorios remotos, locales o personas con las que colaboremos. Un ejemplo de un archivo .gitignore es el siguiente:\nSi no identifican algunos de los elementos de ahí no hay de qué preocuparse, mejor nos enfocámos en los tipos de archivos que nosotros necesitamos que NO sean tomados en cuenta por git, es decir, que no queremos que se suban a nuestro repositorio de github por ejemplo ni en la gestión de versiones. Si es el caso que tenemos que hacer el knit de un Rmarkdown y necesitamos un archivo .csv para renderizarlo, pero solamente queremos el archivo Rmakrdown en el sistema de git, pues en nuestro archivo .gitignore escribimos .csv, guardamos el archivo y listo.\nEn el caso del readme es un archivo que debe de dar una idea de qué tenemos en el repositorio. Es una guía para nosotros mismos u otros usuarios que vayan a hacer uso del repositorio y nuestro código. En github los readme se ven así:\nUna vez que el repositorio haya sido creado, vamos a encontrarnos con una opción que dirá “clone or download”. Vamos a hacer click en clone y la dirección que allí sale la tenemos que copiar (ctrl + c). La imagen muestra lo que sucede al hacer clone en el botón verde que ofrece github:\nYa con la información de la dirección del repositorio copiada, vamos a llevarla a nuestra terminal:\n2. Clonar repositorio en nuestra computadora\nUna vez que tenemos creado el repositorio y la dirección copiada, vamos a abrir nuestra terminal. Si es usuario de windows puede usar el powershell. Lo primero que vamos a ver es una dirección y allí tendremos que dirigirnos a la carpeta donde deseamos colocar el repositorio.\n\ncd ~ #Esto me va a llevar al home\n\n\ncd Desktop/ #Me lleva al escritorio\n\n\nls #Me da lista de los elementos que existen en la dirección que estoy\n\n\ncd primeras_letras_nombre <TAB> #Con TAB autocompleta el nombre\n\nEste procedimiento lo vamos realizando hasta llegar a la carpeta en la cual queremos clonar el repositorio.\nEl segundo paso es clonar el repositorio:\n\ngit clone <dirección del repositorio que copiamos>\n\nPor último nos dirigimos a la carpeta del repositorio\n\ncd <nombre_repositorio>\n\n¡Listo! Ya tenemos el repositorio remoto tal cual en nuestra computadora local. A partir de aquí podemos trabajar en nuestros archivos.\n3. Crear una rama en el repositorio\n¿Qué pasa si queremos hacer una variación en el código sin miedo a dañar lo que ya tenemos? Pues bien, git nos permite hacer ramas que son una bifurcación del trabajo que llevamos realizado hasta ese momento y que si luego queremos, podemos volver a integrar a la rama principal.\nCuano tenemos un repositorio la rama principal está nombrada como master. A partir de esta rama master podemos hacer ramas con los nombres que nosotros queramos. La idea de las ramas es trabajar de manera ordenada, en donde en mi rama master siempre debemos de tener código limpio y funcional y lo que sean nuevas tareas, mejoras o experimentos lo hagamos en ramas que se bifurcan a partir de la rama master.\nCuando el trabajo realizado en la rama sea funcional y limpio, lo podemos integrar a la rama master. Caso contrario podemos olvidarnos de la rama y volver a nuestra rama master.\nCrear rama\n\ngit checkout -b <NOMBRE_RAMA> #Nos crea y dirige a la nueva rama\n\nVerificar rama en la que estamos\n\ngit status\n\ncambiar entre ramas\nPara cambiar entre ramas que ya existen NO hay que usar “-b”\n\ngit checkout <NOMBRE_RAMA>\n\n4. Subir/bajar cambios\nComo estamos trabajando con un repositorio remoto y uno local, vamos a querer sincronizar los cambios. Estos cambios pasarán a estar en la historia del proyecto como commits. Un commit es un punto en la historia del proyecto que muestra el trabajo realizado en ese momento. En el flujo del trabajo que uno tenga es recomendable hacer commits regularmente y hacer el push de manera regular para asegurarnos de no perder el trabajo.\n4.1 Revisar estado de los cambios  Cuando tengamos cambios en nuestros archivos, podemos revisar cuáles han cambiado y si los tenemos incluidos o no en nuestro registro de cambios\n\ngit status\n\n4.2 Agregar cambios Los archivos que queramos agregar a la historia del proyecto lo podemos hacer de dos maneras, una donde indicamos explícitamente el archivo específico:\n\ngit add <NOMBRE_ARCHIVO>\n\nO de tal manera en que agreguemos todos los archivos con cambios de una vez\n\ngit add .\n\n4.3 Someter cambios a la historia de git\n\ngit commit -m \"MENSAJE_CORTO\"\n\nEl mensaje sirve para darnos a nosotros mismos o a colaboradores, una idea del cambio que se trabajó.\n4.4 Subir cambios al repositorio remoto\n\ngit push\n\n4.5 Bajar cambios del repositorio remoto Si estamos trabajando con colaboradores y han integrado cambios en el repositorio remoto que nosotros no tenemos en nuestro repositorio local, los podemos traer de la siguiente manera:\n\ngit pull\n\n¿Qué tenemos hasta acá?\nUna idea básica sobre git, de sus componentes, del flujo de trabajo y de los principales comandos que se usan. Un tutorial con un ejemplo básico vendrá despueś.\nReferencias\nhttps://git-scm.com/book/en/v2 https://git-scm.com/book/es/v1/Ramificaciones-en-Git-Procedimientos-b%C3%A1sicos-para-ramificar-y-fusionar\n\n\n\n",
    "preview": "posts/2021-12-11-otra-intro-a-git/images/files.png",
    "last_modified": "2021-12-18T00:44:33-07:00",
    "input_file": {}
  }
]
